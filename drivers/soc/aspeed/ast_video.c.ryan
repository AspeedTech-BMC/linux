/********************************************************************************
* File Name     : ast_video.c
* Author         : Ryan Chen
* Description   : AST Video Engine Controller
* 
* Copyright (C) 2012-2020  ASPEED Technology Inc.
* This program is free software; you can redistribute it and/or modify 
* it under the terms of the GNU General Public License as published by the Free Software Foundation; 
* either version 2 of the License, or (at your option) any later version. 
* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; 
* without even the implied warranty of MERCHANTABILITY or 
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
* You should have received a copy of the GNU General Public License 
* along with this program; if not, write to the Free Software 
* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
*
*   Version      : 1.0
*   History      : 
*      1. 2013/04/30 Ryan Chen create this file 
*    
********************************************************************************/

#include <linux/slab.h>
#include <linux/sched.h>

#include <linux/module.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/types.h>
#include <linux/interrupt.h>
#include <linux/mm.h>
#include <linux/delay.h>
#include <linux/miscdevice.h>
#include <linux/kthread.h>

#include <linux/hwmon-sysfs.h>

#include <asm/io.h>
#include <asm/uaccess.h>
#include <plat/regs-video.h>
#include <mach/ast_video.h>
#include <mach/hardware.h>
#include <plat/aspeed.h>
#include <plat/ast-scu.h>


//#define CONFIG_AST_VIDEO_LOCK
#define CONFIG_AUTO_MODE

#define CONFIG_AST_VIDEO_DEBUG

#ifdef CONFIG_AST_VIDEO_DEBUG
	#define VIDEO_DBG(fmt, args...) printk("%s(): " fmt, __FUNCTION__, ## args)
#else
	#define VIDEO_DBG(fmt, args...)
#endif

/*************************************************************************************/
//video engine initial
struct video_eng_config {
	video_source		input_source;
	unsigned char		Auto_Mode;		//force 1:auto,  0:capture and compress 
	unsigned char		Mode_420;
	unsigned char		Direct_Mode;	//0: Force Sync mode, 1: Auto Direct mode
//TODO ~~ GRAY mode
	//encryption
	unsigned char		RC4_Enable;
	unsigned char		encrypt_key[256];

	unsigned char		Y_Table;
	
	//Visual_Lossless enable	
	unsigned char		Visual_Lossless;
	unsigned char		Advance_Table;

	//scaling on/off
	unsigned char		scaling;
	unsigned short	User_Width;
	unsigned short	User_Height;	
};

//video jpeg engine initial
struct jpeg_eng_config {
	unsigned char		Mode_420;

	unsigned char		Y_Table;
	
	//Visual_Lossless enable	
	unsigned char		Visual_Lossless;
	unsigned char		Advance_Table;

	//scaling on/off
	unsigned char		scaling;	
	unsigned short	User_Width;
	unsigned short	User_Height;	
};

struct ast_screen_info {
	unsigned short	x;
	unsigned short	y;
};

//video [stream/frame mode info]
struct ast_video_info {
	unsigned char		first_frame;
	unsigned long		Data_Length;	//block len; actual size should * 4
	unsigned long		Blocks_Changed;	
};

/*************************************************************************************/
#define VIDEOIOC_BASE       'V'

#define AST_VIDEO_ENG_INIT_IOCTX				_IOW(VIDEOIOC_BASE, 0x10, struct video_eng_config)
#define AST_JPEG_ENG_INIT_IOCTX				_IOW(VIDEOIOC_BASE, 0x11, struct jpeg_eng_config)
#define AST_VIDEO_MODE_DETECT_IOC				_IO(VIDEOIOC_BASE, 0x12)
#define AST_VIDEO_AUTOPHASE_ADJUST_IOC		_IO(VIDEOIOC_BASE, 0x13)
#define AST_VIDEO_AUTOPOSITION_ADJUST_IOCRX	_IOR(VIDEOIOC_BASE, 0x14, struct ast_screen_info)
#define AST_VIDEO_JPEG_TRIGGER_IOCTX			_IOR(VIDEOIOC_BASE, 0x15, int)
#define AST_VIDEO_AUTOMODE_TRIGGER_IOCTX		_IOR(VIDEOIOC_BASE, 0x16, struct ast_video_info)
#define AST_VIDEO_CAPTURE_TRIGGER_IOCTX		_IO(VIDEOIOC_BASE, 0x17)		
#define AST_VIDEO_COMPRESSION_TRIGGER_IOCTX	_IOR(VIDEOIOC_BASE, 0x18, struct ast_video_info)
#define AST_VIDEO_GET_MEM_SIZE_IOCRX			_IOR(VIDEOIOC_BASE, 0x19, unsigned long)
#define AST_VIDEO_GET_JPEG_OFFSET_IOCRX		_IOR(VIDEOIOC_BASE, 0x1A, unsigned long)
#define AST_VIDEO_VGA_DISABLE					_IO(VIDEOIOC_BASE, 0x1B)		
#define AST_VIDEO_VGA_ENABLE					_IO(VIDEOIOC_BASE, 0x1C)	
/*************************************************************************************/
typedef struct {
	u16	HorizontalActive;
	u16	VerticalActive;
	u16	RefreshRateIndex;
	u32    PixelClock;
} INTERNAL_MODE;

INTERNAL_MODE Internal_Mode[] = {
// 1024x768
  {1024, 768, 0, 65000},
  {1024, 768, 1, 65000},
  {1024, 768, 2, 75000},
  {1024, 768, 3, 78750},
  {1024, 768, 4, 94500},
// 1280x1024
  {1280, 1024, 0, 108000},
  {1280, 1024, 1, 108000},
  {1280, 1024, 2, 135000},
  {1280, 1024, 3, 157500},      
// 1600x1200
  {1600, 1200, 0, 162000},
  {1600, 1200, 1, 162000},
  {1600, 1200, 2, 175500},
  {1600, 1200, 3, 189000},
  {1600, 1200, 4, 202500},
  {1600, 1200, 5, 229500},
// 1920x1200 reduce blank
  {1920, 1200, 0, 157000},
  {1920, 1200, 1, 157000},
};

u16  InternalEnhanceModeNumberCount = sizeof (Internal_Mode) / sizeof (INTERNAL_MODE);

typedef struct {
    u16    HorizontalActive;
    u16    VerticalActive;
    u16    RefreshRate;
    u8      ADCIndex1;
    u8      ADCIndex2;
    u8      ADCIndex3;
    u8      ADCIndex5;
    u8      ADCIndex6;
    u8      ADCIndex7;
    u8      ADCIndex8;
    u8      ADCIndex9;
    u8      ADCIndexA;
    u8      ADCIndexF;
    u8      ADCIndex15;
    int       HorizontalShift;
    int       VerticalShift;
} ADC_MODE;

ADC_MODE ADCModeTable[] = {
////////////////////////// 60Hz mode
	{720,480,60,	0x41,	0xF0,	0x48,	0x05,	0x20,	0x58,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	2},
	{848,480,60,	0x42,	0x70,	0x48,	0x05,	0x20,	0x58,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	2},
	{640,480,60,	0x31,	0xF0,	0x48,	0x05,	0x20,	0x60,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	2},
	{720,576,60,	0x38,	0xF0,	0x48,	0x05,	0x20,	0x48,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	2},
	{960,600,60,	0x4C,	0xF0,	0x60,	0x05,	0x20,	0x60,	0x60,	0x60,	0x60,	0x5E,	0xFE,   -1,	0},
	{800,600,60,	0x41,	0xF0,	0x60,	0x05,	0x20,	0x80,	0x60,	0x60,	0x60,	0x5E,	0xFE,   -1,	0},
    {1088,612,60,   0x56,   0xF0,   0x60,   0x05,   0x20,   0x70,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
    {1280,720,60,   0x67,   0xF0,   0xA8,   0x05,   0x20,   0x88,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
    {1360,768,60,   0x6E,   0xF0,   0xA8,   0x05,   0x20,   0x90,   0x60,   0x60,   0x60,   0x5E,   0xFE,    7, 1},
    {1280,768,60,   0x67,   0xF0,   0xA8,   0x05,   0x20,   0x80,   0x60,   0x60,   0x60,   0x5E,   0xFE,    7, 1},
	{1024,768,60,	0x53,	0xF0,	0xA8,	0x05,	0x20,	0x88,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	7},
    {1280,800,60,   0x68,   0xF0,   0xA8,   0x05,   0x20,   0x88,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
    {1152,864,60,   0x5E,   0xF0,   0xA8,   0x05,   0x20,   0x78,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
    {1600,900,60,   0x84,   0xF0,   0xA8,   0x05,   0x20,   0xA8,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
    {1280,960,60,   0x70,   0x70,   0xA8,   0x05,   0x20,   0x70,   0x60,   0x60,   0x60,   0x5E,   0xFE,   -1, 0},
	{1600,1024,60,	0x85,	0xF0,	0xE8,	0x05,	0x20,	0xA8,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{1280,1024,60,	0x69,	0x70,	0xA8,	0x05,	0x20,	0x70,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{1600,1200,60,	0x86,	0xF0,	0xE8,	0x05,	0x20,	0xC0,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
//////////////////////  Not 60Hz mode
	{720,400,70,	0x38,	0x30,	0x48,	0x05,	0x20,	0x6C,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	1},
	{640,480,72,	0x33,	0xF0,	0x48,	0x05,	0x20,	0x28,	0x60,	0x60,	0x60,	0x5E,	0xFE,	 6,	3},
	{640,480,75,	0x34,	0x70,	0x48,	0x05,	0x20,	0x40,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	3},
	{640,480,85,	0x33,	0xF0,	0x48,	0x05,	0x20,	0x38,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	3},
	{800,600,56,	0x3F,	0xF0,	0x60,	0x05,	0x20,	0x48,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{800,600,72,	0x40,	0xF0,	0x60,	0x05,	0x20,	0x78,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{800,600,75,	0x41,	0xF0,	0x60,	0x05,	0x20,	0x50,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{800,600,85,	0x41,	0x70,	0x60,	0x05,	0x20,	0x40,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{1024,768,70,	0x52,	0xF0,	0xA8,	0x05,	0x20,	0x88,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	7},
	{1024,768,75,	0x51,	0xF0,	0xA8,	0x05,	0x20,	0x60,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	1},
	{1024,768,85,	0x55,	0xF0,	0xA8,	0x05,	0x20,	0x60,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	1},
	{1152,864,75,	0x63,	0xF0,	0xA8,	0x05,	0x20,	0x80,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{1280,960,85,	0x6B,	0xF0,	0xE8,	0x05,	0x20,	0xA0,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0},
	{1280,1024,75,	0x69,	0x70,	0xE8,	0x05,	0x20,	0x90,	0x60,	0x60,	0x60,	0x5E,	0xFE,	-1,	0}
};
u16 ADCModeNumberCount = sizeof (ADCModeTable) / sizeof (ADC_MODE);

typedef struct {
	u16    HorizontalTotal;
	u16    VerticalTotal;
	u16    HorizontalActive;
	u16    VerticalActive;
	u8      RefreshRate;
	double    HorizontalFrequency;
	u16    HSyncTime;
	u16    HBackPorch;
	u16    VSyncTime;
	u16    VBackPorch;
	u16    HLeftBorder;
	u16    HRightBorder;
	u16    VBottomBorder;
	u16    VTopBorder;
} VESA_MODE;

//  Note: Modified for modes which have border issue
VESA_MODE ModeTable[] = {
////////////////////////// 60Hz mode
// 720x480 done
  {1056, 497, 720, 480, 60, 29.900, 88, 104, 3, 13, 0, 0, 0, 0},
// 848x480 done
  {1064, 517, 848, 480, 60, 31.160, 88, 91, 3, 26, 0, 0, 0, 0},
  {800, 525, 640, 480, 60, 31.469, 96, 40, 2, 25, 8, 8, 8, 8},
// 720x576
  {912, 597, 720, 576, 60, 35.920, 72, 88, 3, 17, 0, 0, 0, 0},
// 960x600 GTF done
  {1232, 622, 960, 600, 60, 37.320, 96, 136, 3, 18, 0, 0, 0, 0},
  {1056, 628, 800, 600, 60, 37.879, 128, 88, 4, 23, 0, 0, 0, 0},
// 1088x612 GTF done
  {1392, 634, 1088, 612, 60, 38.04, 112, 152, 3, 18, 0, 0, 0, 0},
// 1280x720 GTF done
  {1664, 746, 1280, 720, 60, 44.760, 136, 192, 3, 22, 0, 0, 0, 0},
// 1360x768 GTF done
  {1776, 795, 1360, 768, 60, 47.700, 144, 208, 3, 23, 0, 0, 0, 0},
// 1280x768 done
  {1664, 798, 1280, 768, 60, 47.700, 128, 184, 7, 20, 0, 0, 0, 0},
  {1344, 806, 1024, 768, 60, 48.363, 136, 160, 6, 29, 0, 0, 0, 0},
// 1280x800 GTF done
  {1680, 828, 1280, 800, 60, 49.680, 136, 200, 3, 24, 0, 0, 0, 0},
// 1152x864 GTF done
  {1520, 895, 1152, 864, 60, 53.700, 120, 184, 3, 27, 0, 0, 0, 0},
// 1600x900 GTF done
  {2128, 932, 1600, 900, 60, 55.920, 168, 264, 3, 28, 0, 0, 0, 0},
  {1800, 1000, 1280, 960, 60, 60.000, 112, 312, 3, 36, 0, 0, 0, 0},
// 1600x1024 GTF done
  {2144, 1060, 1600, 1024, 60, 63.600, 168, 272, 3, 32, 0, 0, 0, 0},
  {1688, 1066, 1280, 1024, 60, 63.981, 112, 248, 3, 38, 0, 0, 0, 0},
  {2160, 1250, 1600, 1200, 60, 75.000, 192, 304, 3, 46, 0, 0, 0, 0},
//////////////////////  Not 60Hz mode
  {900, 449, 720, 400, 70, 31.469, 108, 45, 2, 25, 8, 8, 8, 8},
  {832, 520, 640, 480, 72, 37.861, 40, 120, 3, 20, 8, 8, 8, 8},
  {840, 500, 640, 480, 75, 37.500, 64, 120, 3, 16, 0, 0, 0, 0},
  {832, 509, 640, 480, 85, 43.269, 56, 80, 3, 25, 0, 0, 0, 0},
  {1024, 625, 800, 600, 56, 35.156, 72, 128, 2, 22, 0, 0, 0, 0},
  {1040, 666, 800, 600, 72, 48.077, 120, 64, 6, 23, 0, 0, 0, 0},
  {1056, 625, 800, 600, 75, 46.875, 80, 160, 3, 21, 0, 0, 0, 0},
  {1048, 631, 800, 600, 85, 53.674, 64, 152, 3, 27, 0, 0, 0, 0},
  {1328, 806, 1024, 768, 70, 56.476, 136, 144, 6, 29, 0, 0, 0, 0},
  {1312, 800, 1024, 768, 75, 60.023, 96, 176, 3, 28, 0, 0, 0, 0},
  {1376, 808, 1024, 768, 85, 68.677, 96, 208, 3, 36, 0, 0, 0, 0},
  {1600, 900, 1152, 864, 75, 67.500, 128, 256, 3, 32, 0, 0, 0, 0},
  {1728, 1011, 1280, 960, 85, 85.938, 160, 224, 3, 47, 0, 0, 0, 0},
  {1688, 1066, 1280, 1024, 75, 79.976, 144, 248, 3, 38, 0, 0, 0, 0},
  {1728, 1072, 1280, 1024, 85, 91.146, 160, 224, 3, 44, 0, 0, 0, 0},
  {2160, 1250, 1600, 1200, 65, 81.250, 192, 304, 3, 46, 0, 0, 0, 0},
  {2160, 1250, 1600, 1200, 70, 87.500, 192, 304, 3, 46, 0, 0, 0, 0},
  {2160, 1250, 1600, 1200, 75, 93.750, 192, 304, 3, 46, 0, 0, 0, 0},
  {2160, 1250, 1600, 1200, 85, 106.250, 192, 304, 3, 46, 0, 0, 0, 0},
  {2080, 1235, 1920, 1200, 60, 74.038, 32, 80, 6, 26, 0, 0, 0, 0}
};

u32 ModeNumberCount = sizeof (ModeTable)/sizeof(VESA_MODE);

struct fbinfo
{
	u16	x;
	u16	y;
	u8	color_mode;	//0:NON, 1:EGA, 2:VGA, 3:15bpp, 4:16bpp, 5:32bpp
	u32	PixelClock;
};

struct ast_video_data {
	struct device		*misc_dev;
	void __iomem		*reg_base;			/* virtual */
	int 	irq;				//Video IRQ number 
	phys_addr_t             *stream_phy;            /* phy */
	u32                             *stream_virt;           /* virt */
	phys_addr_t             *buff0_phy;             /* phy */
	u32                             *buff0_virt;            /* virt */
	phys_addr_t             *buff1_phy;             /* phy */
	u32                             *buff1_virt;            /* virt */
	phys_addr_t             *bcd_phy;               /* phy */
	u32                             *bcd_virt;              /* virt */
	phys_addr_t             *jpeg_phy;              /* phy */
	u32                             *jpeg_virt;             /* virt */
	phys_addr_t             *jpeg_buf0_phy;              /* phy */
	u32                             *jpeg_buf0_virt;             /* virt */
	phys_addr_t             *jpeg_tbl_phy;          /* phy */
	u32                             *jpeg_tbl_virt;         /* virt */
	u32		video_mem_size;				/* video memory size*/
	u32		video_jpeg_offset;				/* assigned jpeg memory size*/

	u8 first_frame;
	u8 mode_change;


	struct video_eng_config	eng_config;
	
	u8 direct_fetch_delay_control;		/* VR010[31:16] */

	struct completion	mode_change_complete;
	struct completion	trigger_complete;
	u16 DigitalDifferentialThreshold;
	u16 AnalogDifferentialThreshold;
	
//JPEG 
	u8 jpeg_encode; 			/* 0: diable 1: enable jpeg file encode */
	struct jpeg_eng_config		jpeg_config;

	u32 flag;

	u32 thread_flag;
	struct task_struct 		*thread_task;

	struct fbinfo				src_fbinfo;
	struct fbinfo				dest_fbinfo;
	struct completion			complete;	
	u32		sts;
	u8		stage;
	struct ast_video_plat_data		*plat_data;		
	u32 	bandwidth;


	bool 		is_open;
	spinlock_t      drv_lock;     
};

//  RC4 structure
struct rc4_state
{
    int x;
    int y;
    int m[256];
};
 
static inline void
ast_video_write(struct ast_video_data *ast_video, u32 val, u32 reg)
{
//	VIDEO_DBG("write offset: %x, val: %x \n",reg,val);
#ifdef CONFIG_AST_VIDEO_LOCK
	//unlock 
	writel(VIDEO_PROTECT_UNLOCK, ast_video->reg_base);
	writel(val, ast_video->reg_base + reg);
	//lock
	writel(0xaa,ast_video->reg_base);	
#else
	//Video is lock after reset, need always unlock 
	//unlock 
	writel(VIDEO_PROTECT_UNLOCK, ast_video->reg_base);
	writel(val, ast_video->reg_base + reg);
#endif	
}

static inline u32
ast_video_read(struct ast_video_data *ast_video, u32 reg)
{
	u32 val = readl(ast_video->reg_base + reg);
//	VIDEO_DBG("read offset: %x, val: %x \n",reg,val);
	return val;
}

/************************************************ JPEG ***************************************************************************************/
void ast_init_jpeg_table(struct ast_video_data *ast_video)
{
	int i=0;
	int base=0;
	//JPEG header default value:
	for(i = 0; i<12; i++) {
		base = (1024*i);
		ast_video->jpeg_tbl_virt[base + 0] = 0xE0FFD8FF;
		ast_video->jpeg_tbl_virt[base + 1] = 0x464A1000;
		ast_video->jpeg_tbl_virt[base + 2] = 0x01004649;
		ast_video->jpeg_tbl_virt[base + 3] = 0x60000101;
		ast_video->jpeg_tbl_virt[base + 4] = 0x00006000;
		ast_video->jpeg_tbl_virt[base + 5] = 0x0F00FEFF;
		ast_video->jpeg_tbl_virt[base + 6] = 0x00002D05;
		ast_video->jpeg_tbl_virt[base + 7] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 8] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 9] = 0x00DBFF00;
		ast_video->jpeg_tbl_virt[base + 44] = 0x081100C0;
		ast_video->jpeg_tbl_virt[base + 45] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 47] = 0x03011102;
		ast_video->jpeg_tbl_virt[base + 48] = 0xC4FF0111;
		ast_video->jpeg_tbl_virt[base + 49] = 0x00001F00;
		ast_video->jpeg_tbl_virt[base + 50] = 0x01010501;
		ast_video->jpeg_tbl_virt[base + 51] = 0x01010101;
		ast_video->jpeg_tbl_virt[base + 52] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 53] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 54] = 0x04030201;
		ast_video->jpeg_tbl_virt[base + 55] = 0x08070605;
		ast_video->jpeg_tbl_virt[base + 56] = 0xFF0B0A09;
		ast_video->jpeg_tbl_virt[base + 57] = 0x10B500C4;
		ast_video->jpeg_tbl_virt[base + 58] = 0x03010200;
		ast_video->jpeg_tbl_virt[base + 59] = 0x03040203;
		ast_video->jpeg_tbl_virt[base + 60] = 0x04040505;
		ast_video->jpeg_tbl_virt[base + 61] = 0x7D010000;
		ast_video->jpeg_tbl_virt[base + 62] = 0x00030201;
		ast_video->jpeg_tbl_virt[base + 63] = 0x12051104;
		ast_video->jpeg_tbl_virt[base + 64] = 0x06413121;
		ast_video->jpeg_tbl_virt[base + 65] = 0x07615113;
		ast_video->jpeg_tbl_virt[base + 66] = 0x32147122;
		ast_video->jpeg_tbl_virt[base + 67] = 0x08A19181;
		ast_video->jpeg_tbl_virt[base + 68] = 0xC1B14223;
		ast_video->jpeg_tbl_virt[base + 69] = 0xF0D15215;
		ast_video->jpeg_tbl_virt[base + 70] = 0x72623324;
		ast_video->jpeg_tbl_virt[base + 71] = 0x160A0982;
		ast_video->jpeg_tbl_virt[base + 72] = 0x1A191817;
		ast_video->jpeg_tbl_virt[base + 73] = 0x28272625;
		ast_video->jpeg_tbl_virt[base + 74] = 0x35342A29;
		ast_video->jpeg_tbl_virt[base + 75] = 0x39383736;
		ast_video->jpeg_tbl_virt[base + 76] = 0x4544433A;
		ast_video->jpeg_tbl_virt[base + 77] = 0x49484746;
		ast_video->jpeg_tbl_virt[base + 78] = 0x5554534A;
		ast_video->jpeg_tbl_virt[base + 79] = 0x59585756;
		ast_video->jpeg_tbl_virt[base + 80] = 0x6564635A;
		ast_video->jpeg_tbl_virt[base + 81] = 0x69686766;
		ast_video->jpeg_tbl_virt[base + 82] = 0x7574736A;
		ast_video->jpeg_tbl_virt[base + 83] = 0x79787776;
		ast_video->jpeg_tbl_virt[base + 84] = 0x8584837A;
		ast_video->jpeg_tbl_virt[base + 85] = 0x89888786;
		ast_video->jpeg_tbl_virt[base + 86] = 0x9493928A;
		ast_video->jpeg_tbl_virt[base + 87] = 0x98979695;
		ast_video->jpeg_tbl_virt[base + 88] = 0xA3A29A99;
		ast_video->jpeg_tbl_virt[base + 89] = 0xA7A6A5A4;
		ast_video->jpeg_tbl_virt[base + 90] = 0xB2AAA9A8;
		ast_video->jpeg_tbl_virt[base + 91] = 0xB6B5B4B3;
		ast_video->jpeg_tbl_virt[base + 92] = 0xBAB9B8B7;
		ast_video->jpeg_tbl_virt[base + 93] = 0xC5C4C3C2;
		ast_video->jpeg_tbl_virt[base + 94] = 0xC9C8C7C6;
		ast_video->jpeg_tbl_virt[base + 95] = 0xD4D3D2CA;
		ast_video->jpeg_tbl_virt[base + 96] = 0xD8D7D6D5;
		ast_video->jpeg_tbl_virt[base + 97] = 0xE2E1DAD9;
		ast_video->jpeg_tbl_virt[base + 98] = 0xE6E5E4E3;
		ast_video->jpeg_tbl_virt[base + 99] = 0xEAE9E8E7;
		ast_video->jpeg_tbl_virt[base + 100] = 0xF4F3F2F1;
		ast_video->jpeg_tbl_virt[base + 101] = 0xF8F7F6F5;
		ast_video->jpeg_tbl_virt[base + 102] = 0xC4FFFAF9;
		ast_video->jpeg_tbl_virt[base + 103] = 0x00011F00;
		ast_video->jpeg_tbl_virt[base + 104] = 0x01010103;
		ast_video->jpeg_tbl_virt[base + 105] = 0x01010101;
		ast_video->jpeg_tbl_virt[base + 106] = 0x00000101;
		ast_video->jpeg_tbl_virt[base + 107] = 0x00000000;
		ast_video->jpeg_tbl_virt[base + 108] = 0x04030201;
		ast_video->jpeg_tbl_virt[base + 109] = 0x08070605;
		ast_video->jpeg_tbl_virt[base + 110] = 0xFF0B0A09;
		ast_video->jpeg_tbl_virt[base + 111] = 0x11B500C4;
		ast_video->jpeg_tbl_virt[base + 112] = 0x02010200;
		ast_video->jpeg_tbl_virt[base + 113] = 0x04030404;
		ast_video->jpeg_tbl_virt[base + 114] = 0x04040507;
		ast_video->jpeg_tbl_virt[base + 115] = 0x77020100;
		ast_video->jpeg_tbl_virt[base + 116] = 0x03020100;
		ast_video->jpeg_tbl_virt[base + 117] = 0x21050411;
		ast_video->jpeg_tbl_virt[base + 118] = 0x41120631;
		ast_video->jpeg_tbl_virt[base + 119] = 0x71610751;
		ast_video->jpeg_tbl_virt[base + 120] = 0x81322213;
		ast_video->jpeg_tbl_virt[base + 121] = 0x91421408;
		ast_video->jpeg_tbl_virt[base + 122] = 0x09C1B1A1;
		ast_video->jpeg_tbl_virt[base + 123] = 0xF0523323;
		ast_video->jpeg_tbl_virt[base + 124] = 0xD1726215;
		ast_video->jpeg_tbl_virt[base + 125] = 0x3424160A;
		ast_video->jpeg_tbl_virt[base + 126] = 0x17F125E1;
		ast_video->jpeg_tbl_virt[base + 127] = 0x261A1918;
		ast_video->jpeg_tbl_virt[base + 128] = 0x2A292827;
		ast_video->jpeg_tbl_virt[base + 129] = 0x38373635;
		ast_video->jpeg_tbl_virt[base + 130] = 0x44433A39;
		ast_video->jpeg_tbl_virt[base + 131] = 0x48474645;
		ast_video->jpeg_tbl_virt[base + 132] = 0x54534A49;
		ast_video->jpeg_tbl_virt[base + 133] = 0x58575655;
		ast_video->jpeg_tbl_virt[base + 134] = 0x64635A59;
		ast_video->jpeg_tbl_virt[base + 135] = 0x68676665;
		ast_video->jpeg_tbl_virt[base + 136] = 0x74736A69;
		ast_video->jpeg_tbl_virt[base + 137] = 0x78777675;
		ast_video->jpeg_tbl_virt[base + 138] = 0x83827A79;
		ast_video->jpeg_tbl_virt[base + 139] = 0x87868584;
		ast_video->jpeg_tbl_virt[base + 140] = 0x928A8988;
		ast_video->jpeg_tbl_virt[base + 141] = 0x96959493;
		ast_video->jpeg_tbl_virt[base + 142] = 0x9A999897;
		ast_video->jpeg_tbl_virt[base + 143] = 0xA5A4A3A2;
		ast_video->jpeg_tbl_virt[base + 144] = 0xA9A8A7A6;
		ast_video->jpeg_tbl_virt[base + 145] = 0xB4B3B2AA;
		ast_video->jpeg_tbl_virt[base + 146] = 0xB8B7B6B5;
		ast_video->jpeg_tbl_virt[base + 147] = 0xC3C2BAB9;
		ast_video->jpeg_tbl_virt[base + 148] = 0xC7C6C5C4;
		ast_video->jpeg_tbl_virt[base + 149] = 0xD2CAC9C8;
		ast_video->jpeg_tbl_virt[base + 150] = 0xD6D5D4D3;
		ast_video->jpeg_tbl_virt[base + 151] = 0xDAD9D8D7;
		ast_video->jpeg_tbl_virt[base + 152] = 0xE5E4E3E2;
		ast_video->jpeg_tbl_virt[base + 153] = 0xE9E8E7E6;
		ast_video->jpeg_tbl_virt[base + 154] = 0xF4F3F2EA;
		ast_video->jpeg_tbl_virt[base + 155] = 0xF8F7F6F5;
		ast_video->jpeg_tbl_virt[base + 156] = 0xDAFFFAF9;
		ast_video->jpeg_tbl_virt[base + 157] = 0x01030C00;
		ast_video->jpeg_tbl_virt[base + 158] = 0x03110200;
		ast_video->jpeg_tbl_virt[base + 159] = 0x003F0011;

		//Table 0
		if (i==0) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x0D140043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x0C0F110F;
			ast_video->jpeg_tbl_virt[base + 12] = 0x11101114;
			ast_video->jpeg_tbl_virt[base + 13] = 0x17141516;
			ast_video->jpeg_tbl_virt[base + 14] = 0x1E20321E;
			ast_video->jpeg_tbl_virt[base + 15] = 0x3D1E1B1B;
			ast_video->jpeg_tbl_virt[base + 16] = 0x32242E2B;
			ast_video->jpeg_tbl_virt[base + 17] = 0x4B4C3F48;
			ast_video->jpeg_tbl_virt[base + 18] = 0x44463F47;
			ast_video->jpeg_tbl_virt[base + 19] = 0x61735A50;
			ast_video->jpeg_tbl_virt[base + 20] = 0x566C5550;
			ast_video->jpeg_tbl_virt[base + 21] = 0x88644644;
			ast_video->jpeg_tbl_virt[base + 22] = 0x7A766C65;
			ast_video->jpeg_tbl_virt[base + 23] = 0x4D808280;
			ast_video->jpeg_tbl_virt[base + 24] = 0x8C978D60;
			ast_video->jpeg_tbl_virt[base + 25] = 0x7E73967D;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF7B80;
			ast_video->jpeg_tbl_virt[base + 27] = 0x1F014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x272D2121;
			ast_video->jpeg_tbl_virt[base + 29] = 0x3030582D;
			ast_video->jpeg_tbl_virt[base + 30] = 0x697BB958;
			ast_video->jpeg_tbl_virt[base + 31] = 0xB8B9B97B;
			ast_video->jpeg_tbl_virt[base + 32] = 0xB9B8A6A6;
			ast_video->jpeg_tbl_virt[base + 33] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 34] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 35] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 36] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 37] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 38] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 39] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 40] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 41] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 42] = 0xB9B9B9B9;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFFB9B9B9;
		}
		//Table 1
		if (i==1) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x0C110043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x0A0D0F0D;
			ast_video->jpeg_tbl_virt[base + 12] = 0x0F0E0F11;
			ast_video->jpeg_tbl_virt[base + 13] = 0x14111213;
			ast_video->jpeg_tbl_virt[base + 14] = 0x1A1C2B1A;
			ast_video->jpeg_tbl_virt[base + 15] = 0x351A1818;
			ast_video->jpeg_tbl_virt[base + 16] = 0x2B1F2826;
			ast_video->jpeg_tbl_virt[base + 17] = 0x4142373F;
			ast_video->jpeg_tbl_virt[base + 18] = 0x3C3D373E;
			ast_video->jpeg_tbl_virt[base + 19] = 0x55644E46;
			ast_video->jpeg_tbl_virt[base + 20] = 0x4B5F4A46;
			ast_video->jpeg_tbl_virt[base + 21] = 0x77573D3C;
			ast_video->jpeg_tbl_virt[base + 22] = 0x6B675F58;
			ast_video->jpeg_tbl_virt[base + 23] = 0x43707170;
			ast_video->jpeg_tbl_virt[base + 24] = 0x7A847B54;
			ast_video->jpeg_tbl_virt[base + 25] = 0x6E64836D;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF6C70;
			ast_video->jpeg_tbl_virt[base + 27] = 0x1B014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x22271D1D;
			ast_video->jpeg_tbl_virt[base + 29] = 0x2A2A4C27;
			ast_video->jpeg_tbl_virt[base + 30] = 0x5B6BA04C;
			ast_video->jpeg_tbl_virt[base + 31] = 0xA0A0A06B;
			ast_video->jpeg_tbl_virt[base + 32] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 33] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 34] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 35] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 36] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 37] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 38] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 39] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 40] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 41] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 42] = 0xA0A0A0A0;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFFA0A0A0;
		}
		//Table 2
		if (i==2) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x090E0043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x090A0C0A;
			ast_video->jpeg_tbl_virt[base + 12] = 0x0C0B0C0E;
			ast_video->jpeg_tbl_virt[base + 13] = 0x110E0F10;
			ast_video->jpeg_tbl_virt[base + 14] = 0x15172415;
			ast_video->jpeg_tbl_virt[base + 15] = 0x2C151313;
			ast_video->jpeg_tbl_virt[base + 16] = 0x241A211F;
			ast_video->jpeg_tbl_virt[base + 17] = 0x36372E34;
			ast_video->jpeg_tbl_virt[base + 18] = 0x31322E33;
			ast_video->jpeg_tbl_virt[base + 19] = 0x4653413A;
			ast_video->jpeg_tbl_virt[base + 20] = 0x3E4E3D3A;
			ast_video->jpeg_tbl_virt[base + 21] = 0x62483231;
			ast_video->jpeg_tbl_virt[base + 22] = 0x58564E49;
			ast_video->jpeg_tbl_virt[base + 23] = 0x385D5E5D;
			ast_video->jpeg_tbl_virt[base + 24] = 0x656D6645;
			ast_video->jpeg_tbl_virt[base + 25] = 0x5B536C5A;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF595D;
			ast_video->jpeg_tbl_virt[base + 27] = 0x16014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x1C201818;
			ast_video->jpeg_tbl_virt[base + 29] = 0x22223F20;
			ast_video->jpeg_tbl_virt[base + 30] = 0x4B58853F;
			ast_video->jpeg_tbl_virt[base + 31] = 0x85858558;
			ast_video->jpeg_tbl_virt[base + 32] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 33] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 34] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 35] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 36] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 37] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 38] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 39] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 40] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 41] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 42] = 0x85858585;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF858585;
		}
		//Table 3
		if (i==3) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x070B0043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x07080A08;
			ast_video->jpeg_tbl_virt[base + 12] = 0x0A090A0B;
			ast_video->jpeg_tbl_virt[base + 13] = 0x0D0B0C0C;
			ast_video->jpeg_tbl_virt[base + 14] = 0x11121C11;
			ast_video->jpeg_tbl_virt[base + 15] = 0x23110F0F;
			ast_video->jpeg_tbl_virt[base + 16] = 0x1C141A19;
			ast_video->jpeg_tbl_virt[base + 17] = 0x2B2B2429;
			ast_video->jpeg_tbl_virt[base + 18] = 0x27282428;
			ast_video->jpeg_tbl_virt[base + 19] = 0x3842332E;
			ast_video->jpeg_tbl_virt[base + 20] = 0x313E302E;
			ast_video->jpeg_tbl_virt[base + 21] = 0x4E392827;
			ast_video->jpeg_tbl_virt[base + 22] = 0x46443E3A;
			ast_video->jpeg_tbl_virt[base + 23] = 0x2C4A4A4A;
			ast_video->jpeg_tbl_virt[base + 24] = 0x50565137;
			ast_video->jpeg_tbl_virt[base + 25] = 0x48425647;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF474A;
			ast_video->jpeg_tbl_virt[base + 27] = 0x12014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x161A1313;
			ast_video->jpeg_tbl_virt[base + 29] = 0x1C1C331A;
			ast_video->jpeg_tbl_virt[base + 30] = 0x3D486C33;
			ast_video->jpeg_tbl_virt[base + 31] = 0x6C6C6C48;
			ast_video->jpeg_tbl_virt[base + 32] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 33] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 34] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 35] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 36] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 37] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 38] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 39] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 40] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 41] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 42] = 0x6C6C6C6C;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF6C6C6C;
		}
		//Table 4
		if (i==4) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x06090043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x05060706;
			ast_video->jpeg_tbl_virt[base + 12] = 0x07070709;
			ast_video->jpeg_tbl_virt[base + 13] = 0x0A09090A;
			ast_video->jpeg_tbl_virt[base + 14] = 0x0D0E160D;
			ast_video->jpeg_tbl_virt[base + 15] = 0x1B0D0C0C;
			ast_video->jpeg_tbl_virt[base + 16] = 0x16101413;
			ast_video->jpeg_tbl_virt[base + 17] = 0x21221C20;
			ast_video->jpeg_tbl_virt[base + 18] = 0x1E1F1C20;
			ast_video->jpeg_tbl_virt[base + 19] = 0x2B332824;
			ast_video->jpeg_tbl_virt[base + 20] = 0x26302624;
			ast_video->jpeg_tbl_virt[base + 21] = 0x3D2D1F1E;
			ast_video->jpeg_tbl_virt[base + 22] = 0x3735302D;
			ast_video->jpeg_tbl_virt[base + 23] = 0x22393A39;
			ast_video->jpeg_tbl_virt[base + 24] = 0x3F443F2B;
			ast_video->jpeg_tbl_virt[base + 25] = 0x38334338;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF3739;
			ast_video->jpeg_tbl_virt[base + 27] = 0x0D014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x11130E0E;
			ast_video->jpeg_tbl_virt[base + 29] = 0x15152613;
			ast_video->jpeg_tbl_virt[base + 30] = 0x2D355026;
			ast_video->jpeg_tbl_virt[base + 31] = 0x50505035;
			ast_video->jpeg_tbl_virt[base + 32] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 33] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 34] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 35] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 36] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 37] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 38] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 39] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 40] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 41] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 42] = 0x50505050;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF505050;
		}
		//Table 5
		if (i==5) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x04060043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x03040504;
			ast_video->jpeg_tbl_virt[base + 12] = 0x05040506;
			ast_video->jpeg_tbl_virt[base + 13] = 0x07060606;
			ast_video->jpeg_tbl_virt[base + 14] = 0x09090F09;
			ast_video->jpeg_tbl_virt[base + 15] = 0x12090808;
			ast_video->jpeg_tbl_virt[base + 16] = 0x0F0A0D0D;
			ast_video->jpeg_tbl_virt[base + 17] = 0x16161315;
			ast_video->jpeg_tbl_virt[base + 18] = 0x14151315;
			ast_video->jpeg_tbl_virt[base + 19] = 0x1D221B18;
			ast_video->jpeg_tbl_virt[base + 20] = 0x19201918;
			ast_video->jpeg_tbl_virt[base + 21] = 0x281E1514;
			ast_video->jpeg_tbl_virt[base + 22] = 0x2423201E;
			ast_video->jpeg_tbl_virt[base + 23] = 0x17262726;
			ast_video->jpeg_tbl_virt[base + 24] = 0x2A2D2A1C;
			ast_video->jpeg_tbl_virt[base + 25] = 0x25222D25;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF2526;
			ast_video->jpeg_tbl_virt[base + 27] = 0x09014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x0B0D0A0A;
			ast_video->jpeg_tbl_virt[base + 29] = 0x0E0E1A0D;
			ast_video->jpeg_tbl_virt[base + 30] = 0x1F25371A;
			ast_video->jpeg_tbl_virt[base + 31] = 0x37373725;
			ast_video->jpeg_tbl_virt[base + 32] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 33] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 34] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 35] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 36] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 37] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 38] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 39] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 40] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 41] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 42] = 0x37373737;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF373737;
		}
		//Table 6
		if (i==6) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x02030043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01020202;
			ast_video->jpeg_tbl_virt[base + 12] = 0x02020203;
			ast_video->jpeg_tbl_virt[base + 13] = 0x03030303;
			ast_video->jpeg_tbl_virt[base + 14] = 0x04040704;
			ast_video->jpeg_tbl_virt[base + 15] = 0x09040404;
			ast_video->jpeg_tbl_virt[base + 16] = 0x07050606;
			ast_video->jpeg_tbl_virt[base + 17] = 0x0B0B090A;
			ast_video->jpeg_tbl_virt[base + 18] = 0x0A0A090A;
			ast_video->jpeg_tbl_virt[base + 19] = 0x0E110D0C;
			ast_video->jpeg_tbl_virt[base + 20] = 0x0C100C0C;
			ast_video->jpeg_tbl_virt[base + 21] = 0x140F0A0A;
			ast_video->jpeg_tbl_virt[base + 22] = 0x1211100F;
			ast_video->jpeg_tbl_virt[base + 23] = 0x0B131313;
			ast_video->jpeg_tbl_virt[base + 24] = 0x1516150E;
			ast_video->jpeg_tbl_virt[base + 25] = 0x12111612;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF1213;
			ast_video->jpeg_tbl_virt[base + 27] = 0x04014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x05060505;
			ast_video->jpeg_tbl_virt[base + 29] = 0x07070D06;
			ast_video->jpeg_tbl_virt[base + 30] = 0x0F121B0D;
			ast_video->jpeg_tbl_virt[base + 31] = 0x1B1B1B12;
			ast_video->jpeg_tbl_virt[base + 32] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 33] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 34] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 35] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 36] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 37] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 38] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 39] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 40] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 41] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 42] = 0x1B1B1B1B;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF1B1B1B;
		}
		//Table 7
		if (i==7) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x01020043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 12] = 0x01010102;
			ast_video->jpeg_tbl_virt[base + 13] = 0x02020202;
			ast_video->jpeg_tbl_virt[base + 14] = 0x03030503;
			ast_video->jpeg_tbl_virt[base + 15] = 0x06030202;
			ast_video->jpeg_tbl_virt[base + 16] = 0x05030404;
			ast_video->jpeg_tbl_virt[base + 17] = 0x07070607;
			ast_video->jpeg_tbl_virt[base + 18] = 0x06070607;
			ast_video->jpeg_tbl_virt[base + 19] = 0x090B0908;
			ast_video->jpeg_tbl_virt[base + 20] = 0x080A0808;
			ast_video->jpeg_tbl_virt[base + 21] = 0x0D0A0706;
			ast_video->jpeg_tbl_virt[base + 22] = 0x0C0B0A0A;
			ast_video->jpeg_tbl_virt[base + 23] = 0x070C0D0C;
			ast_video->jpeg_tbl_virt[base + 24] = 0x0E0F0E09;
			ast_video->jpeg_tbl_virt[base + 25] = 0x0C0B0F0C;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF0C0C;
			ast_video->jpeg_tbl_virt[base + 27] = 0x03014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x03040303;
			ast_video->jpeg_tbl_virt[base + 29] = 0x04040804;
			ast_video->jpeg_tbl_virt[base + 30] = 0x0A0C1208;
			ast_video->jpeg_tbl_virt[base + 31] = 0x1212120C;
			ast_video->jpeg_tbl_virt[base + 32] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 33] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 34] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 35] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 36] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 37] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 38] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 39] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 40] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 41] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 42] = 0x12121212;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF121212;
		}
		//Table 8
		if (i==8) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x01020043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 12] = 0x01010102;
			ast_video->jpeg_tbl_virt[base + 13] = 0x02020202;
			ast_video->jpeg_tbl_virt[base + 14] = 0x03030503;
			ast_video->jpeg_tbl_virt[base + 15] = 0x06030202;
			ast_video->jpeg_tbl_virt[base + 16] = 0x05030404;
			ast_video->jpeg_tbl_virt[base + 17] = 0x07070607;
			ast_video->jpeg_tbl_virt[base + 18] = 0x06070607;
			ast_video->jpeg_tbl_virt[base + 19] = 0x090B0908;
			ast_video->jpeg_tbl_virt[base + 20] = 0x080A0808;
			ast_video->jpeg_tbl_virt[base + 21] = 0x0D0A0706;
			ast_video->jpeg_tbl_virt[base + 22] = 0x0C0B0A0A;
			ast_video->jpeg_tbl_virt[base + 23] = 0x070C0D0C;
			ast_video->jpeg_tbl_virt[base + 24] = 0x0E0F0E09;
			ast_video->jpeg_tbl_virt[base + 25] = 0x0C0B0F0C;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF0C0C;
			ast_video->jpeg_tbl_virt[base + 27] = 0x02014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x03030202;
			ast_video->jpeg_tbl_virt[base + 29] = 0x04040703;
			ast_video->jpeg_tbl_virt[base + 30] = 0x080A0F07;
			ast_video->jpeg_tbl_virt[base + 31] = 0x0F0F0F0A;
			ast_video->jpeg_tbl_virt[base + 32] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 33] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 34] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 35] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 36] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 37] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 38] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 39] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 40] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 41] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 42] = 0x0F0F0F0F;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF0F0F0F;
		}
		//Table 9
		if (i==9) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 13] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 14] = 0x02020302;
			ast_video->jpeg_tbl_virt[base + 15] = 0x04020202;
			ast_video->jpeg_tbl_virt[base + 16] = 0x03020303;
			ast_video->jpeg_tbl_virt[base + 17] = 0x05050405;
			ast_video->jpeg_tbl_virt[base + 18] = 0x05050405;
			ast_video->jpeg_tbl_virt[base + 19] = 0x07080606;
			ast_video->jpeg_tbl_virt[base + 20] = 0x06080606;
			ast_video->jpeg_tbl_virt[base + 21] = 0x0A070505;
			ast_video->jpeg_tbl_virt[base + 22] = 0x09080807;
			ast_video->jpeg_tbl_virt[base + 23] = 0x05090909;
			ast_video->jpeg_tbl_virt[base + 24] = 0x0A0B0A07;
			ast_video->jpeg_tbl_virt[base + 25] = 0x09080B09;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF0909;
			ast_video->jpeg_tbl_virt[base + 27] = 0x02014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x02030202;
			ast_video->jpeg_tbl_virt[base + 29] = 0x03030503;
			ast_video->jpeg_tbl_virt[base + 30] = 0x07080C05;
			ast_video->jpeg_tbl_virt[base + 31] = 0x0C0C0C08;
			ast_video->jpeg_tbl_virt[base + 32] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 33] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 34] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 35] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 36] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 37] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 38] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 39] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 40] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 41] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 42] = 0x0C0C0C0C;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF0C0C0C;
		}
		//Table 10
		if (i==10) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 13] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 14] = 0x01010201;
			ast_video->jpeg_tbl_virt[base + 15] = 0x03010101;
			ast_video->jpeg_tbl_virt[base + 16] = 0x02010202;
			ast_video->jpeg_tbl_virt[base + 17] = 0x03030303;
			ast_video->jpeg_tbl_virt[base + 18] = 0x03030303;
			ast_video->jpeg_tbl_virt[base + 19] = 0x04050404;
			ast_video->jpeg_tbl_virt[base + 20] = 0x04050404;
			ast_video->jpeg_tbl_virt[base + 21] = 0x06050303;
			ast_video->jpeg_tbl_virt[base + 22] = 0x06050505;
			ast_video->jpeg_tbl_virt[base + 23] = 0x03060606;
			ast_video->jpeg_tbl_virt[base + 24] = 0x07070704;
			ast_video->jpeg_tbl_virt[base + 25] = 0x06050706;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF0606;
			ast_video->jpeg_tbl_virt[base + 27] = 0x01014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x01020101;
			ast_video->jpeg_tbl_virt[base + 29] = 0x02020402;
			ast_video->jpeg_tbl_virt[base + 30] = 0x05060904;
			ast_video->jpeg_tbl_virt[base + 31] = 0x09090906;
			ast_video->jpeg_tbl_virt[base + 32] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 33] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 34] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 35] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 36] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 37] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 38] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 39] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 40] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 41] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 42] = 0x09090909;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF090909;
		}
		//Table 11
		if (i==11) {
			ast_video->jpeg_tbl_virt[base + 10] = 0x01010043;
			ast_video->jpeg_tbl_virt[base + 11] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 12] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 13] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 14] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 15] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 16] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 17] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 18] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 19] = 0x02020202;
			ast_video->jpeg_tbl_virt[base + 20] = 0x02020202;
			ast_video->jpeg_tbl_virt[base + 21] = 0x03020101;
			ast_video->jpeg_tbl_virt[base + 22] = 0x03020202;
			ast_video->jpeg_tbl_virt[base + 23] = 0x01030303;
			ast_video->jpeg_tbl_virt[base + 24] = 0x03030302;
			ast_video->jpeg_tbl_virt[base + 25] = 0x03020303;
			ast_video->jpeg_tbl_virt[base + 26] = 0xDBFF0403;
			ast_video->jpeg_tbl_virt[base + 27] = 0x01014300;
			ast_video->jpeg_tbl_virt[base + 28] = 0x01010101;
			ast_video->jpeg_tbl_virt[base + 29] = 0x01010201;
			ast_video->jpeg_tbl_virt[base + 30] = 0x03040602;
			ast_video->jpeg_tbl_virt[base + 31] = 0x06060604;
			ast_video->jpeg_tbl_virt[base + 32] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 33] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 34] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 35] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 36] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 37] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 38] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 39] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 40] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 41] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 42] = 0x06060606;
			ast_video->jpeg_tbl_virt[base + 43] = 0xFF060606;
		}
	}


}

void ast_get_vga_scratch_info(struct ast_video_data *ast_video)
{
	u32 i, Mode_Bandwidth, RefreshRateIndex;
	u32 VGA_Scratch_350, VGA_Scratch_34C;	
	u8 RefreshRate;

	VIDEO_DBG("Get VGA SCRATCH INFO ...\n");
	VGA_Scratch_350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
	//Check VGA Driver supports to write display information in scratch register
	if (SCRATCH_VGA_GET_MODE_HEADER(VGA_Scratch_350) == 0xA8) { 
		//VGA's Color Depth is 0 when real color depth is less than 8
		ast_video->src_fbinfo.color_mode = SCRATCH_VGA_GET_NEW_COLOR_MODE(VGA_Scratch_350); 
		ast_video->src_fbinfo.PixelClock = SCRATCH_VGA_GET_NEW_PIXEL_CLK(VGA_Scratch_350);
		VIDEO_DBG("New Mode Information : Color depth %x, Pixel clk %x \n", ast_video->src_fbinfo.color_mode, ast_video->src_fbinfo.PixelClock);
		//Check Bandwidth
		if (ast_video->src_fbinfo.color_mode == 0) {
			printk("Color Depth is not 16bpp or higher \n");
			printk("disable direct mode \n");
			//ast_video->direct_mode = 0;
		} else {
			//Video uses 32bits
			Mode_Bandwidth = (ast_video->src_fbinfo.PixelClock * (ast_video->src_fbinfo.color_mode + 32)) / 8; 
			printk("Mode_Bandwidth = %d\n", Mode_Bandwidth);
			if (ast_video->bandwidth < Mode_Bandwidth) {
				printk("Band Width is not enough change to direct mode\n");
				//ast_video->direct_mode = 1;
			} else {
				printk("Band Width is enough\n");
				//ast_video->direct_mode = 0;
			}
		}
		
	} else {
		//Judge if bandwidth is not enough then enable direct mode in internal VGA
		VGA_Scratch_34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);
		ast_video->src_fbinfo.color_mode = SCRATCH_VGA_GET_COLOR_MODE(VGA_Scratch_34C);
		RefreshRate = SCRATCH_VGA_GET_REFLASH_RATE(VGA_Scratch_34C);
		VIDEO_DBG("Old Mode Information : color depth %x, reflash rate %x \n", ast_video->src_fbinfo.color_mode, RefreshRate);
		if (ast_video->src_fbinfo.color_mode >= VGA_15BPP_MODE) { //15bpp or higher
			for (i = 0; i < (sizeof(Internal_Mode) / sizeof(INTERNAL_MODE)); i++) { 
				if ((ast_video->src_fbinfo.x == Internal_Mode[i].HorizontalActive) && 
					(ast_video->src_fbinfo.y == Internal_Mode[i].VerticalActive) && 
					(RefreshRateIndex == Internal_Mode[i].RefreshRateIndex)) {

					ast_video->src_fbinfo.PixelClock = Internal_Mode[i].PixelClock;
					printk("Mode_PixelClock = %d\n", ast_video->src_fbinfo.PixelClock);
				}
			}
			//Calculate bandwidth required for this mode
			//Video requires pixelclock * 3, VGA requires pixelclock * bpp / 8
			Mode_Bandwidth = ast_video->src_fbinfo.PixelClock * (4 + 2 * (ast_video->src_fbinfo.color_mode - 2));
			printk("Mode_Bandwidth = %d\n", Mode_Bandwidth);
			if (ast_video->bandwidth < Mode_Bandwidth) {
				printk("Band Width is not enough\n");
				//ast_video->direct_mode = 1;
			}
			else {
				printk("Band Width is enough\n");
				//ast_video->direct_mode = 0;
			}
		} else {
			printk("!!!! Color Depth is not 16bpp or higher\n");
			//ast_video->direct_mode = 0;
		}
	}

}

static u8 ast_get_vga_signal(struct ast_video_data *ast_video)
{
	u32 VR34C, VR350, VR35C;
	u8	color_mode;
	
	VR35C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_35C);
	VR35C &= 0xff000000;

	if(VR35C & (SCRATCH_VGA_PWR_STS_HSYNC | SCRATCH_VGA_PWR_STS_VSYNC)) {
		VIDEO_DBG("No VGA Signal : PWR STS %x \n", VR35C);
		return VGA_NO_SIGNAL;
	} else if (VR35C == SCRATCH_VGA_MASK_REG) {
		VIDEO_DBG("No VGA Signal : MASK %x \n", VR35C);
		return VGA_NO_SIGNAL;
	} else if (VR35C & SCRATCH_VGA_SCREEN_OFF) {
		VIDEO_DBG("No VGA Signal : Screen off %x \n", VR35C);
		return VGA_NO_SIGNAL;		
	} else if (!(VR35C & (SCRATCH_VGA_ATTRIBTE_INDEX_BIT5 | SCRATCH_VGA_MASK_REG | SCRATCH_VGA_CRT_RST | SCRATCH_VGA_RESET | SCRATCH_VGA_ENABLE ))) {
		VIDEO_DBG("NO VGA Signal : unknow %x \n", VR35C);
		return VGA_NO_SIGNAL;
	} else {
		VIDEO_DBG("VGA Signal VR35C %x \n", VR35C);
		VR350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
		if(SCRATCH_VGA_GET_MODE_HEADER(VR350) == 0xA8) {
			color_mode = SCRATCH_VGA_GET_NEW_COLOR_MODE(VR350);
		} else {
			VR34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);	
			if(SCRATCH_VGA_GET_COLOR_MODE(VR34C) >= VGA_15BPP_MODE) 
				color_mode = SCRATCH_VGA_GET_COLOR_MODE(VR34C);
			else
				color_mode = SCRATCH_VGA_GET_COLOR_MODE(VR34C);
		}
		if(color_mode == 0) {
			VIDEO_DBG("EGA Mode \n");
			ast_video->src_fbinfo.color_mode = EGA_MODE;
			return EGA_MODE;
		} else if (color_mode == 1) {
			VIDEO_DBG("VGA Mode \n");
			ast_video->src_fbinfo.color_mode = VGA_MODE;			
			return VGA_MODE;
		} else if (color_mode == 2) {
			VIDEO_DBG("15BPP Mode \n");
			ast_video->src_fbinfo.color_mode = VGA_15BPP_MODE;			
			return VGA_15BPP_MODE;
		} else if (color_mode == 3) {
			VIDEO_DBG("16BPP Mode \n");
			ast_video->src_fbinfo.color_mode = VGA_16BPP_MODE;						
			return VGA_16BPP_MODE;
		} else if (color_mode == 4) {
			VIDEO_DBG("32BPP Mode \n");
			ast_video->src_fbinfo.color_mode = VGA_32BPP_MODE;						
			return VGA_32BPP_MODE;
		} else {
			printk("TODO ... unknow ..\n");
			ast_video->src_fbinfo.color_mode = VGA_MODE;						
			return VGA_MODE;
		}
	
	}		
}

static void ast_video_set_compress(struct ast_video_data *ast_video)
{
#if 0
	u32 compress_mode = ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL);

    if (ast_video->frame_config.VQMode == 1)
		compress_mode |= VIDEO_4COLOR_VQ_ENCODE;
    else
        compress_mode &= ~VIDEO_4COLOR_VQ_ENCODE;


    switch (ast_video->frame_config.mode) {
        case 0:
			compress_mode |= VIDEO_DCT_ONLY_ENCODE;
    	    break;
        case 1:
            compress_mode &= ~(VIDEO_4COLOR_VQ_ENCODE |VIDEO_DCT_ONLY_ENCODE);
    	    break;
    	case 2:
			compress_mode |= VIDEO_4COLOR_VQ_ENCODE;
            break;
        case 3: //No one ....
//			compress_mode |= VIDEO_DCT_ONLY_ENCODE | ;
			printk("ERROR .....\n");
            break;
        default:
			printk("ERROR \n");
            compress_mode |= VIDEO_DCT_ONLY_ENCODE;
            break;
    }
	compress_mode |= VIDEO_HQ_DCT_LUM(ast_video->frame_config.AdvanceTableSelector);	
	compress_mode |= VIDEO_HQ_DCT_CHROM((ast_video->frame_config.AdvanceTableSelector + 16));
    compress_mode |= VIDEO_DCT_LUM(ast_video->frame_config.Y_JPEGTableSelector);
    compress_mode |= VIDEO_DCT_CHROM(ast_video->frame_config.UV_JPEGTableSelector);
    if (ast_video->frame_config.Visual_Lossless == 1) 
		compress_mode |= VIDEO_HQ_ENABLE;
    else 
		compress_mode &= ~VIDEO_HQ_ENABLE;

	ast_video_write(ast_video, compress_mode, AST_VIDEO_COMPRESS_CTRL);
#endif	
}

static void ast_video_set_direct_fatch(struct ast_video_data *ast_video, u8 DirectMode)
{
#if 0
	u32 vga_base;
	u32 H_Start, H_End, V_Start, V_End;
	u32 ctrl = ast_video_read(ast_video, AST_VIDEO_PASS_CTRL);

	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
	
	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));	
	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS)); 	

	VIDEO_DBG("Get H_Start = %d, H_End = %d, V_Start = %d, V_End = %d\n", H_Start, H_End, V_Start, V_End);

	ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
	ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
	VIDEO_DBG("source : x = %d, y = %d , color mode = %x \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y,ast_video->src_fbinfo.color_mode);

	VIDEO_DBG("mode : %d\n",DirectMode);

	if(DirectMode) {
		ctrl &= ~(VIDEO_16BPP_MODE_555 | VIDEO_16BPP_MODE | VIDEO_DVO_INPUT_DELAY_MASK);
		
		if(ast_video->src_fbinfo.color_mode == VGA_16BPP_MODE)
			ctrl |= VIDEO_16BPP_MODE | VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH | VIDEO_DVO_INPUT_DELAY(0x4);
		else {
			ctrl |= VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH | VIDEO_DVO_INPUT_DELAY(0x4);
		}
		ast_video_write(ast_video, ctrl , AST_VIDEO_PASS_CTRL);
		
		vga_base = ast_video->plat_data->get_vga_base();
		
		VIDEO_DBG("vga base = %x \n",vga_base );
		
		ast_video_write(ast_video, vga_base, AST_VIDEO_DIRECT_BASE);	
		
		ast_video_write(ast_video, VIDEO_FETCH_TIMING(0) |
						VIDEO_FETCH_LINE_OFFSET(ast_video->src_fbinfo.x * 4)
						, AST_VIDEO_DIRECT_CTRL);		
		
	} else {
		ctrl &=~(VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH);
		ctrl |= VIDEO_INTERNAL_DE | VIDEO_16BPP_MODE | VIDEO_DVO_INPUT_DELAY(0x4);
		ast_video_write(ast_video, ctrl, AST_VIDEO_PASS_CTRL); 

		ast_video_write(ast_video, VIDEO_HSYNC_PIXEL_FIRST_SET(H_Start - 1) | 
						VIDEO_HSYNC_PIXEL_LAST_SET(H_End), 
						AST_VIDEO_TIMING_H);
		ast_video_write(ast_video, VIDEO_VSYNC_PIXEL_FIRST_SET(V_Start) | 
						VIDEO_VSYNC_PIXEL_LAST_SET(V_End + 1), 
						AST_VIDEO_TIMING_V);
	
	}
#endif	
}

static void ast_video_mode_detect_trigger(struct ast_video_data *ast_video)
{
	while(!(ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & VIDEO_CAPTURE_BUSY)) {
		printk("Capture Eng busy !! 0x04 : %x TODO ~~\n", ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL));
	}
	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & 
						~(VIDEO_DETECT_TRIGGER)
						,AST_VIDEO_SEQ_CTRL);

	init_completion(&ast_video->trigger_complete);

	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
						VIDEO_DETECT_TRIGGER 
						,AST_VIDEO_SEQ_CTRL);			

	wait_for_completion_interruptible(&ast_video->trigger_complete);
}

static u8 ast_video_auto_mode_trigger(struct ast_video_data *ast_video, struct ast_video_info *video_info)
{
	if(ast_video->mode_change) {
		ast_video->mode_change = 0;
		return 1;
	}
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
				~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER | VIDEO_COMPRESS_JPEG_MODE), 
				AST_VIDEO_SEQ_CTRL);

	if(ast_video->first_frame) 	{
		//full frame 
		video_info->first_frame = 1;
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) &
					~VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
	} else {
		//diff frame 
		video_info->first_frame = 0;
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) &
					VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);
	}
	ast_video->first_frame = 0;
	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
				~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_FORCE_IDLE |VIDEO_COMPRESS_TRIGGER) , AST_VIDEO_PASS_CTRL);	

	init_completion(&ast_video->trigger_complete);

	//trigger 	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
				(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER), AST_VIDEO_SEQ_CTRL); 


	wait_for_completion_interruptible(&ast_video->trigger_complete);

	video_info->Data_Length = ast_video_read(ast_video, AST_VIDEO_COMPRESS_DATA_COUNT) * 4;
	video_info->Blocks_Changed = GET_BLOCK_CHG(ast_video_read(ast_video, AST_VIDEO_COMPRESS_BLOCK_COUNT));

	return 0;
}

static u8 ast_video_jpeg_trigger(struct ast_video_data *ast_video, u32 *size)
{

#if 1
	//use vm trigger 
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) &
				~(VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER), AST_VM_SEQ_CTRL);

	init_completion(&ast_video->trigger_complete);

	//trigger	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VM_SEQ_CTRL) |
				(VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER), AST_VM_SEQ_CTRL);							

	
#else	
	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
				~(VIDEO_CAPTURE_TRIGGER | VIDEO_COMPRESS_TRIGGER)) | 
				VIDEO_COMPRESS_JPEG_MODE, 
				AST_VIDEO_SEQ_CTRL);

	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_BCD_CTRL) &
				~VIDEO_BCD_CHG_EN, AST_VIDEO_BCD_CTRL);

	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
				~VIDEO_CAPTURE_FORMATE_MASK) | JPEG_MODE, AST_VIDEO_PASS_CTRL);	

	//trigger	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
				(VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER), AST_VIDEO_SEQ_CTRL);							
#endif	
	
	wait_for_completion_interruptible(&ast_video->trigger_complete);


	*size = ast_video_read(ast_video, AST_VM_COMPRESS_FRAME_END);
	return 0;

}

static int ast_video_compression_trigger(struct ast_video_data *ast_video, struct ast_video_info *video_info)
{


	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
				~(VIDEO_COMPRESS_FORCE_IDLE | VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER), 
				AST_VIDEO_SEQ_CTRL);

	init_completion(&ast_video->trigger_complete);

	//trigger 	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
				VIDEO_COMPRESS_TRIGGER, AST_VIDEO_SEQ_CTRL); 

	wait_for_completion_interruptible(&ast_video->trigger_complete);

	video_info->first_frame = 1;
	video_info->Data_Length = ast_video_read(ast_video, AST_VIDEO_COMPRESS_DATA_COUNT) * 4;
	video_info->Blocks_Changed = GET_BLOCK_CHG(ast_video_read(ast_video, AST_VIDEO_COMPRESS_BLOCK_COUNT));
	
	return 0;

}

static int ast_video_capture_trigger(struct ast_video_data *ast_video)
{


	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
				~(VIDEO_COMPRESS_FORCE_IDLE | VIDEO_COMPRESS_TRIGGER | VIDEO_CAPTURE_TRIGGER), 
				AST_VIDEO_SEQ_CTRL);

	init_completion(&ast_video->trigger_complete);

	//trigger 	
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
				VIDEO_CAPTURE_TRIGGER, AST_VIDEO_SEQ_CTRL); 

	wait_for_completion_interruptible(&ast_video->trigger_complete);
	return 0;	

}

static irqreturn_t ast_video_handler(int this_irq, void *dev_id)
{
	struct ast_video_data *ast_video = (struct ast_video_data *) dev_id;
	
	u32 sts = ast_video_read(ast_video, AST_VIDEO_INT_STS);
	u32 buff0, buff1;

//	VIDEO_DBG("isr %x  \n", sts);
	
	if (sts & VIDEO_MODE_DETECT_WDT) {
		VIDEO_DBG("VIDEO_MODE_DETECT_WDT \n");
		ast_video_write(ast_video, VIDEO_MODE_DETECT_WDT, AST_VIDEO_INT_STS);
		ast_video->mode_change = 1;
		ast_video->first_frame = 1;
	} 

	if (sts & VIDEO_MODE_DETECT_RDY) {
		VIDEO_DBG("VIDEO_MODE_DETECT_RDY \n");
		ast_video_write(ast_video, VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_STS);
		complete(&ast_video->trigger_complete);
		ast_video->first_frame = 1;
	}

	if (sts & VIDEO_CAPTURE_COMPLETE) {
		VIDEO_DBG("VIDEO_CAPTURE_COMPLETE \n");
		ast_video_write(ast_video, VIDEO_CAPTURE_COMPLETE, AST_VIDEO_INT_STS);
		complete(&ast_video->trigger_complete);
	}

	if (sts & VIDEO_COMPRESS_COMPLETE) {
		VIDEO_DBG("VIDEO_COMPRESS_COMPLETE \n");
		ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE, AST_VIDEO_INT_STS);
		ast_video->flag = VIDEO_COMPRESS_COMPLETE;
		//swap		
		buff0 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF0);
		buff1 = ast_video_read(ast_video, AST_VIDEO_SOURCE_BUFF1);
		ast_video_write(ast_video, buff1, AST_VIDEO_SOURCE_BUFF0);
		ast_video_write(ast_video, buff0, AST_VIDEO_SOURCE_BUFF1);
//		if(ast_video->mode_change)
//			ast_video->compress_error = 1;
//		else
//			ast_video->compress_error = 0;
		complete(&ast_video->trigger_complete);
	}

	if (sts & VIDEO_COMPRESS_PKT_COMPLETE) {
		VIDEO_DBG("VIDEO_COMPRESS_PKT_COMPLETE TODO ..............\n");
		ast_video_write(ast_video, VIDEO_COMPRESS_PKT_COMPLETE, AST_VIDEO_INT_STS);
//		complete(&ast_video->trigger_complete);
	}

	if (sts & VIDEO_FRAME_COMPLETE) {
		VIDEO_DBG("VIDEO_FRAME_COMPLETE TODO ...\n");
		ast_video_write(ast_video, VIDEO_FRAME_COMPLETE, AST_VIDEO_INT_STS);		
//		complete(&ast_video->trigger_complete);
	}
	
	return IRQ_HANDLED;
}

static void AutoPhase_Adjust(struct ast_video_data *ast_video)
{
}

static u32 JudgeMode(struct ast_video_data *ast_video)
{
#if 0
	u32 HorizontalCount, =  ReadMMIOLong (MODEDETECTION_STATUS_READBACK) & 0x00000FFF,
                     
  u32 VerticalLine =   (ReadMMIOLong (MODEDETECTION_STATUS_READBACK) & 0x0FFF0000) >> 16)

    u8      i, ModeIndex, ColorDepthIndex, FrameRateIndex, ScanLineIndex;
    u16    ModeID;
    u32     Scratch_Register;
    double    temp;

//    VideoEngineInfo->CompressData.HDebug = HorizontalCount;
//    VideoEngineInfo->CompressData.VDebug = VerticalLine;
    if ((HorizontalCount == 0xFFF) || (VerticalLine == 0xFFF)) {
       return FALSE; 
    }
//  Find nearest mode in 60Hz table list
    for (i = 0; i < 18; i++) {
        if (VerticalLine >= ModeTable[i].VerticalTotal) {
            ModeIndex = i;
            VideoEngineInfo->SourceModeInfo.ModeIndex = i;
            VideoEngineInfo->SourceModeInfo.X = ModeTable[i].HorizontalActive;
            VideoEngineInfo->SourceModeInfo.Y = ModeTable[i].VerticalActive;
            VideoEngineInfo->SourceModeInfo.RefreshRate = 60;
            VideoEngineInfo->CompressData.SourceFrameSize = ModeTable[i].HorizontalActive * ModeTable[i].VerticalActive * (24 / 8);
        }
    }
    for (i = 0; i < ModeNumberCount; i++) {
//  Calculate horizontal frequency rate
        temp = (1.0 / ((double)HorizontalCount / SAMPLE_RATE)) / 1000.0;
//          printf ("H_Fre = %f\n", temp);
//          printf ("VT = %d\n", VerticalLine);
        if ((fabs(temp - ModeTable[i].HorizontalFrequency) <= 0.8) &&
             (abs(VerticalLine - ModeTable[i].VerticalTotal) <= 2)) {
            ModeIndex = i;
            VideoEngineInfo->SourceModeInfo.ModeIndex = i;
            VideoEngineInfo->SourceModeInfo.X = ModeTable[i].HorizontalActive;
            VideoEngineInfo->SourceModeInfo.Y = ModeTable[i].VerticalActive;
            VideoEngineInfo->SourceModeInfo.RefreshRate = ModeTable[i].RefreshRate;
            VideoEngineInfo->CompressData.SourceFrameSize = ModeTable[i].HorizontalActive * ModeTable[i].VerticalActive * (24 / 8);
            break;
        }
    }
    i = ModeIndex;

    WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xFFFFE000, ModeTable[i].HBackPorch + ModeTable[i].HLeftBorder + ModeTable[i].HorizontalActive);
    WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xE000FFFF, (ModeTable[i].HBackPorch + ModeTable[i].HLeftBorder) << 16);
    WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_V, 0, ModeTable[i].VBackPorch + ModeTable[i].VTopBorder + ModeTable[i].VerticalActive + ((ModeTable[i].VBackPorch + ModeTable[i].VTopBorder) << 16));

	//External Analog
	if (VideoEngineInfo->INFData.Input_Signale == 2) {
		ADC_write (2, 0x98, 0x01, ADCModeTable[i].ADCIndex1);
		ADC_write (2, 0x98, 0x02, ADCModeTable[i].ADCIndex2);
		ADC_write (2, 0x98, 0x03, ADCModeTable[i].ADCIndex3);
		ADC_write (2, 0x98, 0x05, ADCModeTable[i].ADCIndex5);
		ADC_write (2, 0x98, 0x06, ADCModeTable[i].ADCIndex6);
		ADC_write (2, 0x98, 0x07, ADCModeTable[i].ADCIndex7);
		ADC_write (2, 0x98, 0x08, ADCModeTable[i].ADCIndex8);
		ADC_write (2, 0x98, 0x09, ADCModeTable[i].ADCIndex9);
		ADC_write (2, 0x98, 0x0a, ADCModeTable[i].ADCIndexA);
		ADC_write (2, 0x98, 0x0e, 0x64);
		ADC_write (2, 0x98, 0x0f, ADCModeTable[i].ADCIndexF);
		ADC_write (2, 0x98, 0x15, ADCModeTable[i].ADCIndex15);
	}

#endif
	return 0;
}

static void AutoPosition_Adjust(struct ast_video_data *ast_video)
{
	u32 H_Start, H_End, V_Start, V_End;
	u32 H_Temp = 0, V_Temp = 0, RefreshRateIndex, ColorDepthIndex;
	u32 VGA_Scratch_Register_350,VGA_Scratch_Register_34C, Color_Depth, Mode_Clock;
	struct video_eng_config	*video_config = &ast_video->eng_config;

	VIDEO_DBG("\n");
Redo:
	ast_video_mode_detect_trigger(ast_video);

	H_Start = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
	H_End = VIDEO_GET_HSYNC_RIGHT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));

	V_Start = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));	
	V_End = VIDEO_GET_VSYNC_BOTTOM(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));	

//	VIDEO_DBG("Get H_Start = %d, H_End = %d, V_Start = %d, V_End = %d\n", H_Start, H_End, V_Start, V_End);

	//Check if cable quality is too bad. If it is bad then we use 0x65 as threshold
	//Because RGB data is arrived slower than H-sync, V-sync. We have to read more times to confirm RGB data is arrived
//	if ((abs(H_Temp - H_Start) > 1) || ((H_Start <= 1) || (V_Start <= 1) || (H_Start == 0x3FF) || (V_Start == 0x3FF))) {
	if ((abs(H_Temp - H_Start) > 1) || ((H_Start <= 1) || (V_Start <= 1) || (H_Start == 0xFFF) || (V_Start == 0xFFF))) {
		H_Temp = VIDEO_GET_HSYNC_LEFT(ast_video_read(ast_video, AST_VIDEO_H_DETECT_STS));
		V_Temp = VIDEO_GET_VSYNC_TOP(ast_video_read(ast_video, AST_VIDEO_V_DETECT_STS));
		goto Redo;
	}

	if(video_config->input_source == VIDEO_SOURCE_INT_VGA) {
		ast_video_write(ast_video, 
				VIDEO_HSYNC_PIXEL_FIRST_SET(H_Start - 1) |
				VIDEO_HSYNC_PIXEL_LAST_SET(H_End),
				AST_VIDEO_TIMING_H);
		
		ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
		ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
		
		printk("screen mode x:%d, y:%d \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y);

		VGA_Scratch_Register_350 = ast_video_read(ast_video, AST_VIDEO_SCRATCH_350);
		VGA_Scratch_Register_34C = ast_video_read(ast_video, AST_VIDEO_SCRATCH_34C);
		
		if (((VGA_Scratch_Register_350 & 0xff00) >> 8) == 0xA8) { 
			//Driver supports to write display information in scratch register
//			printk("Wide Screen Information \n");
			Color_Depth = ((VGA_Scratch_Register_350 & 0xff0000) >> 16); //VGA's Color Depth is 0 when real color depth is less than 8
			Mode_Clock = ((VGA_Scratch_Register_350 & 0xff000000) >> 24);
			if (Color_Depth < 15) {
//				printk("Color Depth is not 16bpp or higher\n");
				video_config->Direct_Mode = 0;
			} else {
//				printk("Color Depth is 16bpp or higher\n");
				video_config->Direct_Mode = 1;
			}
		} else { //Original mode information
			//  Judge if bandwidth is not enough then enable direct mode in internal VGA
			RefreshRateIndex = (VGA_Scratch_Register_34C >> 8) & 0x0F;
			ColorDepthIndex = (VGA_Scratch_Register_34C >> 4) & 0x0F;
	//		printk("Orignal mode information \n");	
			if((ColorDepthIndex == 0xe) || (ColorDepthIndex == 0xf)) {
				video_config->Direct_Mode = 0;
			} else {
				if(ColorDepthIndex > 2) {
					if((ast_video->src_fbinfo.x * ast_video->src_fbinfo.y) > (1024 * 768))
						video_config->Direct_Mode = 1;
					else
						video_config->Direct_Mode = 0;
				} else {
					video_config->Direct_Mode = 0;
				}
			}
		}
	} else if (video_config->input_source == VIDEO_SOURCE_EXT_DIGITAL) {	
		ast_video_write(ast_video, 
				VIDEO_HSYNC_PIXEL_FIRST_SET(H_Start - 1) |
				VIDEO_HSYNC_PIXEL_LAST_SET(H_End),
				AST_VIDEO_TIMING_H);
		
		ast_video->src_fbinfo.x = (H_End - H_Start) + 1;
		ast_video->src_fbinfo.y = (V_End - V_Start) + 1;
		
		printk("src screen mode x:%d, y:%d \n", ast_video->src_fbinfo.x, ast_video->src_fbinfo.y);	
	} else if(video_config->input_source == VIDEO_SOURCE_EXT_ADC) {
        	//External analog
#if 0
		i = VideoEngineInfo->SourceModeInfo.ModeIndex;
            HActive = ModeTable[i].HBackPorch + ModeTable[i].HLeftBorder;
            VActive = ModeTable[i].VBackPorch + ModeTable[i].VTopBorder;
            if (((HActive - 10) < H_Start) && (H_Start < (HActive + 10)) && ((VActive - 10) < V_Start) && (V_Start < (VActive + 10))) {
                printk ("Edge Detection Works\n");
                WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xE000FFFF, (H_Start - 1) << 16);
                WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xFFFFE000, (H_Start - 1) + VideoEngineInfo->SourceModeInfo.X);
		WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_V, 0, (V_Start << 16) + ((V_Start) + VideoEngineInfo->SourceModeInfo.Y));		
            }
            else {
                WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xFFFFE000, ModeTable[i].HBackPorch + ModeTable[i].HLeftBorder + ModeTable[i].HorizontalActive);
                WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_H, 0xE000FFFF, (ModeTable[i].HBackPorch + ModeTable[i].HLeftBorder) << 16);
		WriteMMIOLongANDData (VIDEOENGINE_MODEDETECTIONSETTING_V, 0, ((ModeTable[i].VBackPorch + ModeTable[i].VTopBorder) << 16) + ModeTable[i].VBackPorch + ModeTable[i].VTopBorder + ModeTable[i].VerticalActive);		
            }
#endif	
	} else {
		printk("ERROR ~~ \n");
	}

	//choice for direct or sync mode when internel VGA or CRT
	if( video_config->input_source == VIDEO_SOURCE_INT_VGA ) {
		//Internal timing generation setting
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) |
						VIDEO_INTERNAL_DE, AST_VIDEO_PASS_CTRL); 							
		if(video_config->Direct_Mode) {
			printk("Direct mode \n");
			ast_video_write(ast_video, (ast_video->direct_fetch_delay_control << 16) | 
						(ast_video->src_fbinfo.x * 4), AST_VIDEO_DIRECT_CTRL);
			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) |
						VIDEO_DIRT_FATCH | VIDEO_AUTO_FATCH, 
						AST_VIDEO_PASS_CTRL); 				
		} else {
			printk("Sync mode \n");			
			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
									~VIDEO_DIRT_FATCH, AST_VIDEO_PASS_CTRL); 				
		
		}
	} else if (video_config->input_source == VIDEO_SOURCE_INT_CRT) {		
		printk("Direct mode CRT MEM TODO~~ assign CRT FB address \n");
//		ast_video_write(ast_video, CRT_FB address, AST_VIDEO_DIRECT_BASE);
		ast_video_write(ast_video, (ast_video->direct_fetch_delay_control << 16) | 
					(ast_video->src_fbinfo.x * 4), AST_VIDEO_DIRECT_CTRL);
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) |
							VIDEO_DIRT_FATCH, 
							AST_VIDEO_PASS_CTRL);				
	} 

}

static void ast_video_rc4_enable(struct ast_video_data *ast_video)
{
	int i, j, k, a, StringLength;
	struct rc4_state  s;
	u8 expkey[256];	
	u32     temp;

	struct video_eng_config	*video_config = &ast_video->eng_config;
	
	VIDEO_DBG("\n");

	//key expansion
	StringLength = strlen(video_config->encrypt_key);
//		printk("key %s , len = %d \n",ast_video->EncodeKeys, StringLength);
	for (i = 0; i < 256; i++) {
		expkey[i] = video_config->encrypt_key[i % StringLength];
//				printk(" %x ", expkey[i]);
	}
//		printk("\n");
	//rc4 setup
	s.x = 0;
	s.y = 0;

	for (i = 0; i < 256; i++) {
			s.m[i] = i;
	}

	j = k = 0;
	for (i = 0; i < 256; i++) {
			a = s.m[i];
			j = (unsigned char) (j + a + expkey[k]);
			s.m[i] = s.m[j];
			s.m[j] = a;
			k++;
	}
	for (i = 0; i < 64; i++) {
		temp = s.m[i * 4] + ((s.m[i * 4 + 1]) << 8) + ((s.m[i * 4 + 2]) << 16) + ((s.m[i * 4 + 3]) << 24);
		ast_video_write(ast_video, temp, AST_VIDEO_ENCRYPT_SRAM + i*4);
	}

	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_COMPRESS_CTRL) | VIDEO_ENCRYP_ENABLE, AST_VIDEO_COMPRESS_CTRL);		

}

static void ast_video_scaling_init(struct ast_video_data *ast_video)
{
	u32 HorizontalDownScalingFactor;
	u32 VerticalDownScalingFactor;
	u32 Buffer_Offset = 0;
	struct video_eng_config	*video_config = &ast_video->eng_config;
	VIDEO_DBG("\n");	
	//scaling fector 
	if (video_config->scaling) {
		if ((ast_video->src_fbinfo.x == ast_video->dest_fbinfo.x) && 
			(ast_video->src_fbinfo.y == ast_video->dest_fbinfo.y)) {
			// The same  // 1:1
			ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) &
						~VIDEO_CTRL_DWN_SCALING_MASK, AST_VIDEO_CTRL); 	
			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0); 
			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1); 
			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2); 
			ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3); 
		} else {
			//  Down-Scaling
#ifndef AST_SOC_G5
			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_CTRL) &
						~VIDEO_CTRL_DWN_SCALING_MASK) |
						VIDEO_CTRL_DWN_SCALING(DWN_V1), AST_VIDEO_CTRL); 	
#endif 
			if (ast_video->src_fbinfo.x <= ast_video->dest_fbinfo.x * 2) {
				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING0); 
				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING1); 
				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING2); 
				ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING3); 
			} else {
				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING0); 
				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING1); 
				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING2); 
				ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING3); 
			}
		}
	} else {
		// 1:1
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) &
					~VIDEO_CTRL_DWN_SCALING_MASK, AST_VIDEO_CTRL);	
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0); 
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1); 
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2); 
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3); 
	}

	//HorizontalDownScaling
	if (video_config->scaling) {
		//	Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
		HorizontalDownScalingFactor = (ast_video->src_fbinfo.x - 1) / ((ast_video->dest_fbinfo.x - 1) * 4096);
		if(HorizontalDownScalingFactor < 4096) {
			HorizontalDownScalingFactor = 4096;
		}
	
		if ((HorizontalDownScalingFactor * (ast_video->dest_fbinfo.x - 1)) != (ast_video->src_fbinfo.x - 1) * 4096) {
			HorizontalDownScalingFactor += 1;
		}
		
		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SCAL_FACTOR) &
				VIDEO_H_SCAL_FACTOR_MASK) |
				VIDEO_H_SCAL_FACTOR(HorizontalDownScalingFactor), AST_VIDEO_SCAL_FACTOR); 
	} else {
		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SCAL_FACTOR) &
				VIDEO_H_SCAL_FACTOR_MASK) |
				VIDEO_H_SCAL_FACTOR(0x1000), AST_VIDEO_SCAL_FACTOR); 
	}	

	//VerticalDownScaling
	if (video_config->scaling) {
	//	Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
		VerticalDownScalingFactor = (ast_video->src_fbinfo.y - 1) / ((ast_video->dest_fbinfo.y - 1) * 4096);
		if (VerticalDownScalingFactor < 4096) {
			VerticalDownScalingFactor = 4096;
		}
		if ((VerticalDownScalingFactor * (ast_video->dest_fbinfo.y - 1)) != (ast_video->src_fbinfo.y - 1) * 4096) {
			VerticalDownScalingFactor += 1;
		}
		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SCAL_FACTOR) &
				VIDEO_V_SCAL_FACTOR_MASK) |
				VIDEO_V_SCAL_FACTOR(VerticalDownScalingFactor), AST_VIDEO_SCAL_FACTOR); 
	} else {
		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SCAL_FACTOR) &
				VIDEO_V_SCAL_FACTOR_MASK) |
				VIDEO_V_SCAL_FACTOR(0x1000), AST_VIDEO_SCAL_FACTOR); 
	}	

	//ASt2500 A1 issue fix 
#ifdef AST_SOC_G5	
	if(ast_video->src_fbinfo.x == 1680) {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | (1728 << 16), AST_VIDEO_CAPTURE_WIN); 
	} else {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | ((ast_video->src_fbinfo.x) << 16), AST_VIDEO_CAPTURE_WIN); 
	}
#else
	ast_video_write(ast_video, ast_video->src_fbinfo.y | ((ast_video->src_fbinfo.x) << 16), AST_VIDEO_CAPTURE_WIN); 
#endif

	if(video_config->scaling) {
		ast_video_write(ast_video, ast_video->dest_fbinfo.y | (ast_video->dest_fbinfo.x << 16), AST_VIDEO_COMPRESS_WIN); 
	} else {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | (ast_video->src_fbinfo.x << 16), AST_VIDEO_COMPRESS_WIN); 
	}
	
	if ((ast_video->src_fbinfo.x % 8) == 0) {
		ast_video_write(ast_video, ast_video->src_fbinfo.x * 4, AST_VIDEO_SOURCE_SCAN_LINE); 
	} else {
		Buffer_Offset = ast_video->src_fbinfo.x;
		Buffer_Offset = Buffer_Offset + 16 - (Buffer_Offset % 16);
		Buffer_Offset = Buffer_Offset * 4;
		ast_video_write(ast_video, Buffer_Offset, AST_VIDEO_SOURCE_SCAN_LINE); 
	}
}
static void ast_video_eng_init(struct ast_video_data *ast_video)
{
	u32 CompressSetting, DifferentialSetting = 0;
	struct video_eng_config	*video_config = &ast_video->eng_config;
	
	VIDEO_DBG("\n");
	//capture or frame mode 
	if (video_config->Auto_Mode == 0) {
		//capture mode 
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) &
						~VIDEO_AUTO_COMPRESS, AST_VIDEO_SEQ_CTRL); 							
	} else {
		//frame mode..
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) |
						VIDEO_AUTO_COMPRESS, AST_VIDEO_SEQ_CTRL);
	}

	//420/444 Setting
	if(video_config->Mode_420)	
		ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK) | VIDEO_COMPRESS_FORMAT(YUV420) , AST_VIDEO_SEQ_CTRL);
	else
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) & ~VIDEO_COMPRESS_FORMAT_MASK , AST_VIDEO_SEQ_CTRL);

	/***********************************************/	
	DifferentialSetting = 0;
	//External analog has higher BCD threshold
	if(video_config->input_source <= 2) {
	   	DifferentialSetting += (ast_video->DigitalDifferentialThreshold << 16);
	} else {
		DifferentialSetting += (ast_video->AnalogDifferentialThreshold << 16);
	}
	ast_video_write(ast_video, DifferentialSetting, AST_VIDEO_BCD_CTRL); 

	/***********************************************/			
	//always fix DCT mode 
	CompressSetting = 1;
	
	CompressSetting |= (video_config->Y_Table) << 11;
	CompressSetting |= (video_config->Y_Table + 16) << 6;
	if (video_config->Visual_Lossless == 1) {
		CompressSetting |= (video_config->Advance_Table) << 27;
		CompressSetting |= (video_config->Advance_Table + 16) << 22;
		CompressSetting |= 0x90000;
	} else {
		CompressSetting |= 0x80000;
	}

	ast_video_write(ast_video, CompressSetting, AST_VIDEO_COMPRESS_CTRL); 	
	printk("Mode 420 = %d, Y Table = %d, direct mode %d \n",video_config->Mode_420, video_config->Mode_420, video_config->Direct_Mode);
}

static void ast_video_jpeg_initial(struct ast_video_data *ast_video)
{
	int i, base=0;
	struct jpeg_eng_config	*jpeg_config = &ast_video->jpeg_config;
	
	VIDEO_DBG("\n");
	
	//420/444 Setting
	if(jpeg_config->Mode_420)	{
		ast_video_write(ast_video, VIDEO_COMPRESS_JPEG_MODE | VIDEO_COMPRESS_FORMAT(YUV420) | VIDEO_AUTO_COMPRESS , AST_VM_SEQ_CTRL);
	} else {
		ast_video_write(ast_video, VIDEO_COMPRESS_JPEG_MODE | VIDEO_AUTO_COMPRESS , AST_VM_SEQ_CTRL);
	}
	
	for(i = 0; i<12; i++) {
		base = (1024*i);
		if(jpeg_config->Mode_420)	//yuv420
			ast_video->jpeg_tbl_virt[base + 46] = 0x00220103; //for YUV420 mode
		else 
			ast_video->jpeg_tbl_virt[base + 46] = 0x00110103; //for YUV444 mode)
	}

	/******************** AST2500 *******************************************/
#ifdef AST_SOC_G5	//scaling fector support for AST2500
	ast_video_write(ast_video, 0x10001000, AST_VM_SCAL_FACTOR);

	//ASt2500 A1 issue fix 
	if(ast_video->src_fbinfo.x == 1680) {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | (1728 << 16), AST_VM_CAPTURE_WIN); 
	} else {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | (ast_video->src_fbinfo.x << 16), AST_VM_CAPTURE_WIN); 
	}

	if(jpeg_config->scaling) {
		ast_video_write(ast_video, ast_video->dest_fbinfo.y | (ast_video->dest_fbinfo.x << 16), AST_VM_COMPRESS_WIN); 
	} else {
		ast_video_write(ast_video, ast_video->src_fbinfo.y | (ast_video->src_fbinfo.x << 16), AST_VM_COMPRESS_WIN); 
	}

#endif
	/*********************************************************************************/ 		
	//Fix JPEG encode in 4:20
	ast_video_write(ast_video, 0x00080001 + (jpeg_config->Y_Table <<11) + ((jpeg_config->Y_Table+16)<<6), AST_VM_COMPRESS_CTRL);

}

static void ast_video_scaling(struct ast_video_data *ast_video)
{
	u32 scan_line, v_factor, h_factor;
	struct video_eng_config	*video_config = &ast_video->eng_config;
	u32 ctrl = ast_video_read(ast_video, AST_VIDEO_CTRL);
	if(video_config->scaling) {
		VIDEO_DBG("Scaling Enable\n");
		//Calculate scaling factor D / S = 4096 / Factor	======> Factor = (S / D) * 4096
		v_factor = ((ast_video->src_fbinfo.y - 1) * 4096) / (ast_video->src_fbinfo.y - 1);
		if (v_factor < 4096)
			v_factor = 4096;
		if ((v_factor * (ast_video->src_fbinfo.y - 1)) != (ast_video->src_fbinfo.y - 1) * 4096)
			v_factor += 1;

		//Calculate scaling factor D / S = 4096 / Factor  ======> Factor = (S / D) * 4096
		h_factor = ((ast_video->src_fbinfo.x - 1) * 4096) / (ast_video->src_fbinfo.x - 1);
		if (h_factor < 4096)
		    h_factor = 4096;
		if ((h_factor * (ast_video->src_fbinfo.x - 1)) != (ast_video->src_fbinfo.x - 1) * 4096) 
		    h_factor += 1;

		//Down-Scaling
		ctrl |= VIDEO_CTRL_DWN_SCALING(DWN_V2);
		if(ast_video->src_fbinfo.x <= ast_video->dest_fbinfo.x) {
			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING0);
			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING1);
			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING2);
			ast_video_write(ast_video, 0x00101000, AST_VIDEO_SCALING3);
		} else {
			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING0);
			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING1);
			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING2);
			ast_video_write(ast_video, 0x08080808, AST_VIDEO_SCALING3);
		}
	} else {// 1:1
		VIDEO_DBG("Scaling Disable \n");
		ast_video->dest_fbinfo.x = ast_video->src_fbinfo.x;
		ast_video->dest_fbinfo.y = ast_video->src_fbinfo.y;
		ctrl &= ~VIDEO_CTRL_DWN_SCALING_MASK;
		v_factor = 4096;
		h_factor = 4096;
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING0);
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING1);
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING2);
		ast_video_write(ast_video, 0x00200000, AST_VIDEO_SCALING3);
	}
	ast_video_write(ast_video, ctrl, AST_VIDEO_CTRL);

	VIDEO_DBG("Scaling factor : v : %d , h : %d \n",v_factor, h_factor);
	ast_video_write(ast_video, VIDEO_V_SCAL_FACTOR(v_factor) | VIDEO_H_SCAL_FACTOR(h_factor), AST_VIDEO_SCAL_FACTOR);

	//capture x y 
	ast_video_write(ast_video, VIDEO_CAPTURE_H(ast_video->src_fbinfo.x) |
					VIDEO_CAPTURE_V(ast_video->src_fbinfo.y)
					, AST_VIDEO_CAPTURE_WIN);

	//compression x,y
	ast_video_write(ast_video, VIDEO_COMPRESS_H(ast_video->dest_fbinfo.x) |
					VIDEO_COMPRESS_V(ast_video->dest_fbinfo.y)
					, AST_VIDEO_COMPRESS_WIN);

	// ??? why ??
	if((ast_video->src_fbinfo.x % 8) == 0)
		ast_video_write(ast_video, ast_video->src_fbinfo.x * 4
						, AST_VIDEO_SOURCE_SCAN_LINE);
	else {
		scan_line = ast_video->src_fbinfo.x;
		scan_line = scan_line + 16 - (scan_line % 16);
		scan_line = scan_line * 4;
		ast_video_write(ast_video, scan_line
						, AST_VIDEO_SOURCE_SCAN_LINE);
	}
	
}

static u32 ModeDetection(struct ast_video_data *ast_video)
{
	int i;
	u8 HPolarity_Positive = 0, HPolarity_Negative = 0, VPolarity_Positive = 0, VPolarity_Negative = 0;
	u8 Horizontal_Polarity = 0, Vertical_Polarity = 0;
	u32 Polarity;
	struct video_eng_config	*video_config = &ast_video->eng_config;

	VIDEO_DBG("\n");

	//Set input signal and Check polarity (video engine prefers negative signal)
	switch(video_config->input_source) {
		case VIDEO_SOURCE_INT_VGA:
		case VIDEO_SOURCE_INT_CRT:
			//Direct mode always uses positive/positive so we inverse them
			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
					~VIDEO_FROM_EXT_SOURCE) |
					(VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY),
					AST_VIDEO_PASS_CTRL);
			goto resolution_detect;
			break;
		case VIDEO_SOURCE_EXT_DIGITAL:
			// External digital always uses internal timing generation from video 0.60
			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
							~(VIDEO_DIRT_FATCH |VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY)) |
							VIDEO_INTERNAL_DE, AST_VIDEO_PASS_CTRL);								
			break;
		case VIDEO_SOURCE_EXT_ADC:
			ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) &
							~(VIDEO_DIRT_FATCH |VIDEO_SO_VSYNC_POLARITY | VIDEO_SO_HSYNC_POLARITY)) |
							VIDEO_INTERNAL_DE | VIDEO_EXT_ADC_ATTRIBUTE, AST_VIDEO_PASS_CTRL);								
			break;			
	}

	//trigger 1st mode detection (polarity check)
	ast_video_mode_detect_trigger(ast_video);
	// 0 for negative, 1 for positive, hardware always use rising edge
	for(i=0; i<10; i++) {
		if (ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_VSYNC_POLAR)
			VPolarity_Positive++;
		else
			VPolarity_Negative++;
	}
	
	if (VPolarity_Positive > VPolarity_Negative)
		Vertical_Polarity = 1;
	else
		Vertical_Polarity = 0;
	
	for(i=0; i<10; i++) {
		if (ast_video_read(ast_video, AST_VIDEO_MODE_DET_STS) & VIDEO_DET_HSYNC_POLAR)
			HPolarity_Positive++;
		else
			HPolarity_Negative++;
	}
	
	if (HPolarity_Positive > HPolarity_Negative)
		Horizontal_Polarity = 1;
	else
		Horizontal_Polarity = 0;
	
	VIDEO_DBG("Get polarity \n H_pos : %d, H_Neg : %d, H_pol : %d, \n V_pos : %d, V_Neg : %d, V_pol : %d \n", 
				HPolarity_Positive, HPolarity_Negative, Horizontal_Polarity, 
				VPolarity_Positive, VPolarity_Negative, Vertical_Polarity);

	Polarity = ast_video_read(ast_video, AST_VIDEO_PASS_CTRL);
	
	if(Vertical_Polarity)
		Polarity |= VIDEO_SO_VSYNC_POLARITY;
	else 
		Polarity &= ~VIDEO_SO_VSYNC_POLARITY;
		
	if(Horizontal_Polarity) 
		Polarity |= VIDEO_SO_HSYNC_POLARITY;
	else
		Polarity &= ~VIDEO_SO_HSYNC_POLARITY;
	
	ast_video_write(ast_video, Polarity, AST_VIDEO_PASS_CTRL); 							

resolution_detect:
//  2nd mode detection
	ast_video_mode_detect_trigger(ast_video);

	if(video_config->input_source == VIDEO_SOURCE_EXT_ADC) {
		//	Check mode resolution for external analog only, we will check internal 
		//	and external digital input mode resolution at AutoPosition() function		
		//ADC9883 
		JudgeMode(ast_video);
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) | 
					(VIDEO_INTERNAL_DE | VIDEO_EXT_ADC_ATTRIBUTE), AST_VIDEO_PASS_CTRL); 		
	} else {
		ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_PASS_CTRL) & 
					~(VIDEO_INTERNAL_DE | VIDEO_EXT_ADC_ATTRIBUTE), AST_VIDEO_PASS_CTRL); 		
	}

	//Enable Watchdog detection
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_SEQ_CTRL) | 
		VIDEO_INPUT_MODE_CHG_WDT, AST_VIDEO_SEQ_CTRL);

	return 0;
}

static void ast_video_kthread(void *data)
{
	struct ast_video_data *ast_video = (struct ast_video_data *) data;
	struct video_eng_config	*video_config = &ast_video->eng_config;


	while(!kthread_should_stop())
	{
		ast_video_eng_init(ast_video);
		ast_video_jpeg_initial(ast_video);
	
		ast_video->first_frame = 1;
		ast_video->mode_change = 0;
		init_completion(&ast_video->mode_change_complete);		
		ModeDetection(ast_video);
		if(video_config->input_source == VIDEO_SOURCE_EXT_ADC) {
			AutoPhase_Adjust(ast_video);
		}
		AutoPosition_Adjust(ast_video);
		if(!ast_video->mode_change) {

			printk("wait for mode change : ");
			wait_for_completion_interruptible(&ast_video->mode_change_complete);
			printk("done \n");
		}
	}
}

static void ast_video_ctrl_init(struct ast_video_data *ast_video)
{
	VIDEO_DBG("\n");
	ast_video_write(ast_video, (u32)ast_video->buff0_phy, AST_VIDEO_SOURCE_BUFF0);
	ast_video_write(ast_video, (u32)ast_video->buff1_phy, AST_VIDEO_SOURCE_BUFF1);
	ast_video_write(ast_video, (u32)ast_video->bcd_phy, AST_VIDEO_BCD_BUFF);
	ast_video_write(ast_video, (u32)ast_video->stream_phy, AST_VIDEO_STREAM_BUFF);
	ast_video_write(ast_video, (u32)ast_video->jpeg_tbl_phy, AST_VIDEO_JPEG_HEADER_BUFF);
	ast_video_write(ast_video, (u32)ast_video->jpeg_tbl_phy, AST_VM_JPEG_HEADER_BUFF);		
	ast_video_write(ast_video, (u32)ast_video->jpeg_buf0_phy, AST_VM_SOURCE_BUFF0);
	ast_video_write(ast_video, (u32)ast_video->jpeg_phy, AST_VM_COMPRESS_BUFF);
	ast_video_write(ast_video, 0, AST_VIDEO_COMPRESS_READ);

	//clr int sts
	ast_video_write(ast_video, 0xffffffff, AST_VIDEO_INT_STS);
	ast_video_write(ast_video, VIDEO_COMPRESS_COMPLETE | VIDEO_MODE_DETECT_WDT | VIDEO_MODE_DETECT_RDY, AST_VIDEO_INT_EN);

	//rc4 init reset ..
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) | VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);
	ast_video_write(ast_video, ast_video_read(ast_video, AST_VIDEO_CTRL) & ~VIDEO_CTRL_RC4_RST , AST_VIDEO_CTRL);

	// =============================  JPEG init ===========================================
	ast_init_jpeg_table(ast_video);
	ast_video_write(ast_video,  VM_STREAM_PKT_SIZE(STREAM_3MB), AST_VM_STREAM_SIZE);
	ast_video_write(ast_video,  0x00080000 | VIDEO_DCT_LUM(4) | VIDEO_DCT_CHROM(4 + 16) | VIDEO_DCT_ONLY_ENCODE, AST_VM_COMPRESS_CTRL);

	//WriteMMIOLong(0x1e700238, 0x00000000);
	//WriteMMIOLong(0x1e70023c, 0x00000000);

	ast_video_write(ast_video, 0x00001E00, AST_VM_SOURCE_SCAN_LINE); //buffer pitch
	ast_video_write(ast_video, 0x00000000, 0x268);
	ast_video_write(ast_video, 0x00001234, 0x280);

	ast_video_write(ast_video, 0x00000000, AST_VM_PASS_CTRL);
	ast_video_write(ast_video, 0x00000000, AST_VM_BCD_CTRL);
	
	// ===============================================================================

	//Specification define bit 12:13 must always 0;
	ast_video_write(ast_video, VIDEO_DVO_INPUT_DELAY(0x4), 	AST_VIDEO_PASS_CTRL); 

	ast_video_write(ast_video, VIDEO_STREAM_PKT_N(STREAM_32_PKTS) | 
				VIDEO_STREAM_PKT_SIZE(STREAM_128KB), AST_VIDEO_STREAM_SIZE);

	//CRC/REDUCE_BIT register clear
	ast_video_write(ast_video, 0, AST_VIDEO_CRC1);
	ast_video_write(ast_video, 0, AST_VIDEO_CRC2);
	ast_video_write(ast_video, 0, AST_VIDEO_DATA_TRUNCA);
	ast_video_write(ast_video, 0, AST_VIDEO_COMPRESS_READ);

	ast_video_write(ast_video, (ast_video_read(ast_video, AST_VIDEO_MODE_DETECT) & 0xff) |
									VIDEO_MODE_HOR_TOLER(6) |
									VIDEO_MODE_VER_TOLER(6) |
									VIDEO_MODE_HOR_STABLE(2) |
									VIDEO_MODE_VER_STABLE(2) |
									VIDEO_MODE_EDG_THROD(0x65)
									, AST_VIDEO_MODE_DETECT);	
}

static long ast_video_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
{
	int ret = 0;
	struct miscdevice *c = fp->private_data;
	struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
	void __user *argp = (void __user *)arg;
	u32 data_len;
	struct ast_video_info video_info;
	struct ast_screen_info screen_info;

	switch (cmd) {
		case AST_VIDEO_ENG_INIT_IOCTX:
			if(copy_from_user(&ast_video->eng_config, argp, sizeof(struct video_eng_config))) {
				ret = -EFAULT;
			} else {
				ast_video_eng_init(ast_video);
				if(ast_video->eng_config.RC4_Enable)
					ast_video_rc4_enable(ast_video);
			}
			break;
		case AST_JPEG_ENG_INIT_IOCTX:
			if(copy_from_user(&ast_video->jpeg_config, argp, sizeof(struct jpeg_eng_config))) {
				ret = -EFAULT;
			} else {
				ast_video_jpeg_initial(ast_video);
			}
			break;
		case AST_VIDEO_MODE_DETECT_IOC:
			ModeDetection(ast_video);
			break;
		case AST_VIDEO_AUTOPHASE_ADJUST_IOC:
			break;
		case AST_VIDEO_AUTOPOSITION_ADJUST_IOCRX:
			AutoPosition_Adjust(ast_video);
			screen_info.x = ast_video->src_fbinfo.x;
			screen_info.y = ast_video->src_fbinfo.y;
			ret = copy_to_user((struct ast_screen_info *)argp, &screen_info, sizeof(struct ast_screen_info));
			break;
		case AST_VIDEO_JPEG_TRIGGER_IOCTX: 
			if(ast_video_jpeg_trigger(ast_video, &data_len)) {
				ret = -EFAULT;					
			} else {
				ret = __put_user(data_len, (unsigned long __user *)arg);
			}			
			break;
		case AST_VIDEO_AUTOMODE_TRIGGER_IOCTX:
			printk("AST_VIDEO_AUTOMODE_TRIGGER_IOCTX \n");
			if(ast_video_auto_mode_trigger(ast_video, &video_info)) {
				ret = -EFAULT;
			} else {
				ret = copy_to_user((struct ast_video_info *)argp, &video_info, sizeof(struct ast_video_info));
			}
			printk("AST_VIDEO_AUTOMODE_TRIGGER_IOCTX done \n");			
			break;
		case AST_VIDEO_CAPTURE_TRIGGER_IOCTX:
			if(ast_video_capture_trigger(ast_video)) {
				ret = -EFAULT;
			} 						
			break;
		case AST_VIDEO_COMPRESSION_TRIGGER_IOCTX:
			//struct ast_video_info
			if(ast_video_compression_trigger(ast_video, &video_info)) {
				ret = -EFAULT;
			} else {
				if(copy_to_user((struct ast_video_info *)argp, &video_info, sizeof(struct ast_video_info)))
					ret = -EFAULT;
			}			
			
			break;
		case AST_VIDEO_GET_MEM_SIZE_IOCRX:
			ret = __put_user(ast_video->video_mem_size, (unsigned long __user *)arg);
			break;
		case AST_VIDEO_GET_JPEG_OFFSET_IOCRX:
			ret = __put_user(ast_video->video_jpeg_offset, (unsigned long __user *)arg);
			break;
		case AST_VIDEO_VGA_DISABLE:
			ast_video->plat_data->vga_display(0);
			break;
		case AST_VIDEO_VGA_ENABLE:
			ast_video->plat_data->vga_display(1);
			break;
		default:
			ret = 1;
			break;
	}
	return ret;

}

/** @note munmap handler is done by vma close handler */
static int ast_video_mmap(struct file * file, struct vm_area_struct * vma)
{
        struct miscdevice *c = file->private_data;
        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);
        size_t size = vma->vm_end - vma->vm_start;
        vma->vm_private_data = ast_video;

        if (PAGE_ALIGN(size) > ast_video->video_mem_size) {
                        printk(KERN_ERR "required length exceed the size "
                                   "of physical sram (%x)\n", ast_video->video_mem_size);
                        return -EAGAIN;
        }

        if ((ast_video->stream_phy + (vma->vm_pgoff << PAGE_SHIFT) + size)
                > (ast_video->stream_phy + ast_video->video_mem_size)) {
                        printk(KERN_ERR "required sram range exceed the size "
                                   "of phisical sram\n");
                        return -EAGAIN;
        }

        vma->vm_flags |= VM_IO;
        vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);

        if (io_remap_pfn_range(vma, vma->vm_start,
                        ((u32)ast_video->stream_phy >> PAGE_SHIFT),
                        size,
                        vma->vm_page_prot)) {
                printk(KERN_ERR "remap_pfn_range faile at %s()\n", __func__);
                return -EAGAIN;
        }

        return 0;
}

static int ast_video_open(struct inode *inode, struct file *file)
{
        struct miscdevice *c = file->private_data;
        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);

        VIDEO_DBG("\n");
        spin_lock(&ast_video->drv_lock);

        if (ast_video->is_open) {
                spin_unlock(&ast_video->drv_lock);
                return -EBUSY;
        }

        ast_video->is_open = true;
        spin_unlock(&ast_video->drv_lock);

        return 0;

}

static int ast_video_release(struct inode *inode, struct file *file)
{
        struct miscdevice *c = file->private_data;
        struct ast_video_data *ast_video = dev_get_drvdata(c->this_device);

        VIDEO_DBG("\n");
        spin_lock(&ast_video->drv_lock);

        ast_video->is_open = false;
        spin_unlock(&ast_video->drv_lock);
        return 0;
}

static const struct file_operations ast_video_fops = {
	.owner 			= THIS_MODULE,
	.llseek 			= no_llseek,
	.unlocked_ioctl 	= ast_video_ioctl,
	.open 			= ast_video_open,
	.release 			= ast_video_release,
	.mmap 			= ast_video_mmap,
};

struct miscdevice ast_video_misc = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "ast-video",
	.fops = &ast_video_fops,
};

/************************************************** SYS FS End ***********************************************************/
static int ast_video_probe(struct platform_device *pdev)
{
	struct resource *res0, *res1;
	int ret=0;
	int i;
	u8 color_mode;
	struct ast_video_data *ast_video;
	struct video_eng_config	*video_config;

	res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (NULL == res0) {
		dev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");
		ret = -ENOENT;
		goto out;
	}

	if (!request_mem_region(res0->start, resource_size(res0), res0->name)) {
		dev_err(&pdev->dev, "cannot reserved region\n");
		ret = -ENXIO;
		goto out;
	}

	if(!(ast_video = kzalloc(sizeof(struct ast_video_data), GFP_KERNEL))) {
		return -ENOMEM;
		goto out;
        }
	
	video_config = &ast_video->eng_config;
	
	ast_video->reg_base = ioremap(res0->start, resource_size(res0));
	if (!ast_video->reg_base) {
		ret = -EIO;
		goto out_region0;
	}
	
	res1 = platform_get_resource(pdev, IORESOURCE_DMA, 0);
	if (!res1)
		return -ENODEV;
	
	if (!request_mem_region(res1->start, resource_size(res1), res1->name)) {
		dev_err(&pdev->dev, "cannot reserved region\n");
		ret = -ENXIO;
		goto out_region0;
	}

	//Phy assign
	ast_video->video_mem_size = resource_size(res1);
	VIDEO_DBG("video_mem_size %d MB\n",ast_video->video_mem_size/1024/1024);
	
	ast_video->stream_phy = (phys_addr_t *) res1->start;
	ast_video->buff0_phy = (phys_addr_t *) (res1->start + 0x400000);  //4M : size 10MB
	ast_video->buff1_phy = (phys_addr_t *) (res1->start + 0xe00000);  //14M : size 10MB
	ast_video->bcd_phy = (phys_addr_t *) (res1->start + 0x1800000);   //24M : size 1MB
	ast_video->jpeg_buf0_phy = (phys_addr_t *) (res1->start + 0x1900000);  //25MB: size 10 MB
	ast_video->video_jpeg_offset = 0x2300000;	
	ast_video->jpeg_phy = (phys_addr_t *) (res1->start + 0x2300000);  //35MB: size 4 MB
	ast_video->jpeg_tbl_phy = (phys_addr_t *) (res1->start + 0x2700000);      //39MB: size 1 MB

	VIDEO_DBG("\nstream_phy: %x, buff0_phy: %x, buff1_phy:%x, bcd_phy:%x \njpeg_phy:%x, jpeg_tbl_phy:%x \n",
	        (u32)ast_video->stream_phy, (u32)ast_video->buff0_phy, (u32)ast_video->buff1_phy, (u32)ast_video->bcd_phy, (u32)ast_video->jpeg_phy, (u32)ast_video->jpeg_tbl_phy);


	//virt assign
	ast_video->stream_virt = ioremap(res1->start, resource_size(res1));
	if (!ast_video->stream_virt) {
	        ret = -EIO;
	        goto out_region1;
	}

	ast_video->buff0_virt = (u32)ast_video->stream_virt + 0x400000; //4M : size 10MB
	ast_video->buff1_virt = (u32)ast_video->stream_virt + 0xe00000; //14M : size 10MB
	ast_video->bcd_virt = (u32)ast_video->stream_virt + 0x1800000;  //24M : size 4MB
	ast_video->jpeg_buf0_virt = res1->start + 0x1900000;  //25MB: size x MB
	ast_video->jpeg_virt = (u32)ast_video->stream_virt + 0x2300000; //35MB: size 4 MB
	ast_video->jpeg_tbl_virt = (u32)ast_video->stream_virt + 0x2700000;     //39MB: size 1 MB

	VIDEO_DBG("\nstream_virt: %x, buff0_virt: %x, buff1_virt:%x, bcd_virt:%x \njpeg_virt:%x, jpeg_tbl_virt:%x \n",
	        (u32)ast_video->stream_virt, (u32)ast_video->buff0_virt, (u32)ast_video->buff1_virt, (u32)ast_video->bcd_virt, (u32)ast_video->jpeg_virt, (u32)ast_video->jpeg_tbl_virt);

	memset(ast_video->stream_virt, 0, resource_size(res1));	

	ast_video->irq = platform_get_irq(pdev, 0);
	if (ast_video->irq < 0) {
		dev_err(&pdev->dev, "no irq specified\n");
		ret = -ENOENT;
		goto out_region1;
	}

	ast_video->plat_data = pdev->dev.platform_data;	

	// default config 
	video_config->input_source = VIDEO_SOURCE_INT_VGA;
	video_config->RC4_Enable = 0;
	strcpy(video_config->encrypt_key, "fedcba9876543210");
	video_config->scaling = 0;
	
	//TEST
	ast_video->plat_data->get_vga_base();

	ret = misc_register(&ast_video_misc);
	if (ret){		
		printk(KERN_ERR "VIDEO : failed to request interrupt\n");
		goto out_irq;
	}

	//bandwidth cal utilization 0.4 =  4/10 = 2/5  --> clk * 2 * buswidth(16bits) * 0.4 /8
	VIDEO_DBG("m clk = %d \n",ast_video->plat_data->get_clk());
	ast_video->bandwidth = (ast_video->plat_data->get_clk() /10) * 16;
	VIDEO_DBG("Memory Bandwidth = %d Byte/s\n", ast_video->bandwidth);

//	ast_video->timeout = 5;	
	ast_video->flag = 0;

	platform_set_drvdata(pdev, ast_video);
	dev_set_drvdata(ast_video_misc.this_device, ast_video);

	ast_video_ctrl_init(ast_video);

	ret = request_irq(ast_video->irq, ast_video_handler, IRQF_DISABLED, "ast-video", ast_video);
	if (ret) {
		printk(KERN_INFO "VIDEO: Failed request irq %d\n", ast_video->irq);
		goto out_region1;
	}

	printk(KERN_INFO "ast_video: driver successfully loaded.\n");

	return 0;

out_irq:
	free_irq(ast_video->irq, NULL);

out_region1:
	release_mem_region(res1->start, res1->end - res1->start + 1);	

out_region0:
	release_mem_region(res0->start, res0->end - res0->start + 1);
	
out:
	printk(KERN_WARNING "ast video: driver init failed (ret=%d)!\n", ret);
	return ret;

}

static int ast_video_remove(struct platform_device *pdev)
{
	struct resource *res0, *res1;
	struct ast_video_data *ast_video = platform_get_drvdata(pdev);
	VIDEO_DBG("ast_video_remove\n");

	misc_deregister(&ast_video_misc);

	free_irq(ast_video->irq, ast_video);

	res0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);

	iounmap(ast_video->reg_base);

	release_mem_region(res0->start, res0->end - res0->start + 1);

	res1 = platform_get_resource(pdev, IORESOURCE_DMA, 0);

	iounmap(ast_video->stream_virt);

	release_mem_region(res1->start, res1->end - res1->start + 1);

	return 0;	
}

#ifdef CONFIG_PM
static int 
ast_video_suspend(struct platform_device *pdev, pm_message_t state)
{
	printk("ast_video_suspend : TODO \n");
	return 0;
}

static int 
ast_video_resume(struct platform_device *pdev)
{
	return 0;
}

#else
#define ast_video_suspend        NULL
#define ast_video_resume         NULL
#endif

static const struct platform_device_id ast_video_idtable[] = {
	{
		.name = "ast-video",
//		.driver_data = ast_video_data,
		/* sentinel */
	}
};
MODULE_DEVICE_TABLE(platform, ast_video_idtable);

static struct platform_driver ast_video_driver = {
	.remove 		= ast_video_remove,
	.suspend        = ast_video_suspend,
	.resume         = ast_video_resume,
	.driver  	       = {
	        .name   = "ast-video",
	        .owner  = THIS_MODULE,
	},
	.id_table	= ast_video_idtable,	
};

module_platform_driver_probe(ast_video_driver, ast_video_probe);

MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
MODULE_DESCRIPTION("AST Video Engine driver");
MODULE_LICENSE("GPL");
